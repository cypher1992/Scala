[debug] 
[debug] Initial source changes: 
[debug] 	removed:Set(C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\HotelSingletonClient.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\clientHotelCompanionWithFactory.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\HotelPricingCalculatorSingleton.scala)
[debug] 	added: Set(C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Abstract\abstractHotel.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\TraitTraining\ExtMultiTraits\SecurityConversion.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\ExistsFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\FoldFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\TraitTraining\ExtMultiTraits\Equity.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\TraitTraining\TypeParameters\Securities.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\IntersectFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ImmutableCollection\VectorCollection\VectorCollection.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\SliceFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\TraitTraining\HotelFactory\Hotels.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\TraitTraining\ExtMultiTraits\SecurityBasic.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\DiffFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\TraitTraining\ExtMultiTraits\Bond.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ImmutableCollection\ListCollection\ListCollection.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\NonEmptyFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\FlattenFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\MaxByFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\FlatMapFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Typed_Class\Motel.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\TraitTraining\TypeParameters\SecurtiesFunctions.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\TraitTraining\TypeParameters\Trade.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\ScanFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\TraitTraining\HotelFactory\HotelFactory.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\SortByFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\TakeFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\SizeFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\TailFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\MutableCollection\ArrayCollection.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\ForEachFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\MkStringFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\TraitTraining\TypeParameters\Client.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ImmutableCollection\SequenceCollection\SequenceCollection.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Covariance_TypeWithContraVariance\Equity.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\UnZipFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\IsEmptyFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Covariance_TypeWithContraVariance\Client_Covariance_Type.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Abstract\HotelExtendsAbstract.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\TraitTraining\ExtMultiTraits\Client.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\FindFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\com\projects\financial\TestAlphaAdvantage.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\ReverseIteratorFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ImmutableCollection\MapCollection\MapCollection.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\PartitionFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Typed_Class\Hotel.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\review\Basic\IfElseControl.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\TraitTraining\ExtMultiTraits\Security.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Abstract\CaseHotelExtendedWithAbstact.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ImmutableCollection\QueueCollection\QueueCollection.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\TraitTraining\ExTrait\Equity.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Case\CaseHotel.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\package.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ImmutableCollection\StreamCollection\StreamCollection.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Covariance_TypeWithContraVariance\Fixed_Income.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\TraitTraining\ExtMultiTraits\Trade.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\TraitTraining\ExTrait\Extend_Trait_Equity.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Covariance_TypeWithContraVariance\FinancialnstrumentType.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Singleton\HotelPricingCalculatorSingleton.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Type_Aliasing\TypeAliasVsCaseClassHotel.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\CollectFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\TraitTraining\TypeParameters\FixedIncome.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\GroupByFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Typed_Class\TypedClient.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\TraitTraining\ExTrait\Client.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Covariance_TypeWithContraVariance\FinancialInstrumentTypeContraVariance.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Typed_Class\TypeHotels.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\ReverseFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Implicit\HotelImplictCaseClass.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\MinFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\FilterNotFilterFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\DropWhileFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Abstract\ClientExtendOfHotelAbstract.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Singleton\ClientSingletonHotelCalculator.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\TransposeFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\MinByFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Covariance_TypeWithContraVariance\Financial_Instrument.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\com\projects\financial\Stock.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\HeadWithLastFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\review\Basic\ForControl.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\MaxFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\TraitTraining\HotelFactory\Client.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\ReduceFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Typed_Class\Airbnb.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ImmutableCollection\SetCollection\SetCollection.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\DropFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\TraitTraining\TypeParameters\Equities.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\MapFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ImmutableCollection\ListCollection\MethodList.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\UnionFunc.scala)
[debug] 	modified: Set()
[debug] Invalidated products: Set(C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\ClassesAndObject\client.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\Option$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\Basics.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\WhileLooping$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\Basics$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\LoggerTest.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\FunctionWithReturnOptionType$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\ForComprehension$User$2$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\CompositeFunctionUsingAndThenWithComposed$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\FunctionWithParameters$LongPosition$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\ClassesAndObject\HotelSingletonClient.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\HOF_CalledByNameFunctions.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\CompositeFunctionUsingAndThenWithComposed$delayedInit$body.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\PatternMatching$Location$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\FunctionWithParameters$Stock$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\ClassesAndObject\Airbnb.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\Interest\Investments$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\ClassesAndObject\clientHotelCompanionWithFactory.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\CurryingFunctionWithParameterGroup.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\CompositeFunctionUsingAndThenWithComposed.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\HOF_CallBackFunctionParameter$Investment.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\ClassesAndObject\Motel$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\FunctionalVarArgs.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\HOF_CalledByNameFunctions$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\Option$delayedInit$body.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\HOF.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\FunctionWithReturnOptionType.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\PatternMatching$Company.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\CompositeFunctionUsingAndThenWithComposed$Stock.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\FunctionWithOptionParameters$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\FunctionTyped.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\WhileLooping.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\HOF_CallBackFunctionParameter$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\IfElseStatementAndExpression$User$2$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\Range.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\PatternMatching$Location.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\Range$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\CompositeFunctionUsingAndThenWithComposed$Stock$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\ClassesAndObject\HotelSingletonClient$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\HOF$delayedInit$body.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\FunctionWithOptionParameters.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\ForComprehension$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\HWWorld$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\IfElseStatementAndExpression.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\Interest\Investments.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\Interest\Investments$delayedInit$body.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\FunctionsWithImplictAKADependencyInjection$Items.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\Option$Equity.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\FunctionTyped$delayedInit$body.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\FunctionWithOptionParameters$delayedInit$body.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\Interest\Investments$Investment.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\ClassesAndObject\HotelPricingCalculatorSingleton.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\StringInterpolation$User$2$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\FunctionalVarArgs$delayedInit$body.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\ScalaTypeInference.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\StringInterpolation$User$1.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\FunctionsWithImplictAKADependencyInjection.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\ClassesAndObject\client$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\ClassesAndObject\Motel.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\ClassesAndObject\HotelCompanionObjectWithFactory$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\ForComprehension.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\PatternMatching$Company$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\LoggerTest$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\PatternMatching$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\HOF_CallBackFunctionParameter.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\Option.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\Option$Equity$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\FunctionsWithImplictAKADependencyInjection$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\StringInterpolation.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\ClassesAndObject\HotelCompanionObjectWithFactory.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\HOF_CalledByNameFunctions$delayedInit$body.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\StringInterpolation$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\ClassesAndObject\StoreSystem.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\PatternMatching.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\FunctionWithParameters$LongPosition.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\PatternMatching$delayedInit$body.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\Range$stockOwnerShip$2$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\FunctionsWithImplictAKADependencyInjection$delayedInit$body.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\IfElseStatementAndExpression$User$1.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\ClassesAndObject\HotelPricingCalculatorSingleton$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\FunctionWithOptionParameters$Equity$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\ClassesAndObject\Hotel$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\FunctionWithReturnOptionType$delayedInit$body.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\CurryingFunctionWithParameterGroup$Stock.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\FunctionWithParameters.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\FunctionTyped$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\HOF$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\FunctionWithOptionParameters$Equity.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\FunctionWithParameters$delayedInit$body.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\Range$stockOwnerShip$1.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\ClassesAndObject\clientHotelCompanionWithFactory$delayedInit$body.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\LoggerTest$delayedInit$body.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\HWWorld.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\ClassesAndObject\Airbnb$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\HOF_CallBackFunctionParameter$Investment$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\CurryingFunctionWithParameterGroup$delayedInit$body.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\ClassesAndObject\client$delayedInit$body.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\ClassesAndObject\clientHotelCompanionWithFactory$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\ClassesAndObject\Hotel.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\IfElseStatementAndExpression$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\FunctionWithParameters$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\CurryingFunctionWithParameterGroup$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\FunctionalVarArgs$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\HOF_CallBackFunctionParameter$delayedInit$body.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\FunctionWithParameters$Stock.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\FunctionsWithImplictAKADependencyInjection$Items$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\FunctionsAreObjects$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\ForComprehension$User$1.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\FunctionsAreObjects.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\basics\ScalaTypeInference$.class, C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes\com\local\method\FunctionsWithImplictAKADependencyInjection$Total.class)
[debug] External API changes: API Changes: Set()
[debug] Modified binary dependencies: Set()
[debug] Initial directly invalidated classes: Set(com.local.ClassesAndObject.HotelSingletonClient, com.local.ClassesAndObject.clientHotelCompanionWithFactory, com.local.ClassesAndObject.HotelPricingCalculatorSingleton)
[debug] 
[debug] Sources indirectly invalidated by:
[debug] 	product: Set(C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\method\HOF.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\method\FunctionTyped.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\method\FunctionalVarArgs.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\method\HOF_CallBackFunctionParameter.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\HotelSingletonClient.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\basics\StringInterpolation.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Hotel.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\clientHotelCompanionWithFactory.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\client.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\basics\HWWorld.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\basics\ScalaTypeInference.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\method\CompositeFunctionUsingAndThenWithComposed.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\basics\LoggerTest.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\StoreSystem.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\basics\Range.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\HotelPricingCalculatorSingleton.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\HotelCompanionObjectWithFactory.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\basics\FunctionsAreObjects.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\method\FunctionsWithImplictAKADependencyInjection.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\method\FunctionWithParameters.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Motel.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\basics\WhileLooping.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\basics\PatternMatching.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\basics\Option.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\basics\ForComprehension.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\Interest\Investments.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Airbnb.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\method\HOF_CalledByNameFunctions.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\basics\IfElseStatementAndExpression.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\basics\Basics.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\method\FunctionWithReturnOptionType.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\method\CurryingFunctionWithParameterGroup.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\method\FunctionWithOptionParameters.scala)
[debug] 	binary dep: Set()
[debug] 	external source: Set()
[debug] All initially invalidated classes: Set(com.local.ClassesAndObject.HotelSingletonClient, com.local.ClassesAndObject.clientHotelCompanionWithFactory, com.local.ClassesAndObject.HotelPricingCalculatorSingleton)
[debug] All initially invalidated sources:Set(C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Abstract\abstractHotel.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\TraitTraining\ExtMultiTraits\SecurityConversion.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\method\HOF.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\ExistsFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\method\FunctionTyped.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\method\FunctionalVarArgs.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\method\HOF_CallBackFunctionParameter.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\HotelSingletonClient.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\FoldFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\TraitTraining\ExtMultiTraits\Equity.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\basics\StringInterpolation.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Hotel.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\TraitTraining\TypeParameters\Securities.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\IntersectFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ImmutableCollection\VectorCollection\VectorCollection.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\SliceFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\TraitTraining\HotelFactory\Hotels.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\TraitTraining\ExtMultiTraits\SecurityBasic.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\DiffFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\TraitTraining\ExtMultiTraits\Bond.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ImmutableCollection\ListCollection\ListCollection.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\NonEmptyFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\clientHotelCompanionWithFactory.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\FlattenFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\MaxByFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\FlatMapFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Typed_Class\Motel.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\TraitTraining\TypeParameters\SecurtiesFunctions.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\TraitTraining\TypeParameters\Trade.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\ScanFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\TraitTraining\HotelFactory\HotelFactory.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\SortByFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\TakeFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\SizeFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\client.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\basics\HWWorld.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\TailFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\MutableCollection\ArrayCollection.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\ForEachFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\MkStringFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\TraitTraining\TypeParameters\Client.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ImmutableCollection\SequenceCollection\SequenceCollection.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Covariance_TypeWithContraVariance\Equity.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\UnZipFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\IsEmptyFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Covariance_TypeWithContraVariance\Client_Covariance_Type.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Abstract\HotelExtendsAbstract.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\TraitTraining\ExtMultiTraits\Client.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\basics\ScalaTypeInference.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\FindFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\com\projects\financial\TestAlphaAdvantage.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\ReverseIteratorFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ImmutableCollection\MapCollection\MapCollection.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\PartitionFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\method\CompositeFunctionUsingAndThenWithComposed.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Typed_Class\Hotel.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\review\Basic\IfElseControl.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\TraitTraining\ExtMultiTraits\Security.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\basics\LoggerTest.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Abstract\CaseHotelExtendedWithAbstact.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ImmutableCollection\QueueCollection\QueueCollection.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\StoreSystem.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\TraitTraining\ExTrait\Equity.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Case\CaseHotel.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\basics\Range.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\package.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ImmutableCollection\StreamCollection\StreamCollection.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Covariance_TypeWithContraVariance\Fixed_Income.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\TraitTraining\ExtMultiTraits\Trade.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\TraitTraining\ExTrait\Extend_Trait_Equity.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\HotelPricingCalculatorSingleton.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Covariance_TypeWithContraVariance\FinancialnstrumentType.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Singleton\HotelPricingCalculatorSingleton.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\HotelCompanionObjectWithFactory.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Type_Aliasing\TypeAliasVsCaseClassHotel.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\CollectFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\basics\FunctionsAreObjects.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\TraitTraining\TypeParameters\FixedIncome.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\method\FunctionsWithImplictAKADependencyInjection.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\GroupByFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Typed_Class\TypedClient.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\TraitTraining\ExTrait\Client.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Covariance_TypeWithContraVariance\FinancialInstrumentTypeContraVariance.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\method\FunctionWithParameters.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Typed_Class\TypeHotels.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\ReverseFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Implicit\HotelImplictCaseClass.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\MinFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\FilterNotFilterFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\DropWhileFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Abstract\ClientExtendOfHotelAbstract.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Singleton\ClientSingletonHotelCalculator.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\TransposeFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Motel.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\MinByFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\basics\WhileLooping.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Covariance_TypeWithContraVariance\Financial_Instrument.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\basics\PatternMatching.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\basics\Option.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\com\projects\financial\Stock.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\basics\ForComprehension.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\Interest\Investments.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\HeadWithLastFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Airbnb.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\review\Basic\ForControl.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\MaxFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\method\HOF_CalledByNameFunctions.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\TraitTraining\HotelFactory\Client.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\ReduceFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ClassesAndObject\Typed_Class\Airbnb.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ImmutableCollection\SetCollection\SetCollection.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\basics\IfElseStatementAndExpression.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\basics\Basics.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\DropFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\TraitTraining\TypeParameters\Equities.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\method\FunctionWithReturnOptionType.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\method\CurryingFunctionWithParameterGroup.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\MapFunc.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\method\FunctionWithOptionParameters.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\ImmutableCollection\ListCollection\MethodList.scala, C:\Users\Zero\IdeaProjects\Scala\src\main\scala\com\local\CollectionFunction\UnionFunc.scala)
[debug] Recompiling all 120 sources: invalidated sources (121) exceeded 50.0% of all sources
[info] Compiling 120 Scala sources to C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes ...
[debug] Getting org.scala-sbt:compiler-bridge_2.13:1.2.5:compile for Scala 2.13.0
[debug] Getting org.scala-sbt:compiler-bridge_2.13:1.2.5:compile for Scala 2.13.0
[debug] [zinc] Running cached compiler 463da8b1 for Scala compiler version 2.13.0
[debug] [zinc] The Scala compiler is invoked with:
[debug] 	-bootclasspath
[debug] 	C:\Program Files\Java\jdk1.8.0_211\jre\lib\resources.jar;C:\Program Files\Java\jdk1.8.0_211\jre\lib\rt.jar;C:\Program Files\Java\jdk1.8.0_211\jre\lib\sunrsasign.jar;C:\Program Files\Java\jdk1.8.0_211\jre\lib\jsse.jar;C:\Program Files\Java\jdk1.8.0_211\jre\lib\jce.jar;C:\Program Files\Java\jdk1.8.0_211\jre\lib\charsets.jar;C:\Program Files\Java\jdk1.8.0_211\jre\lib\jfr.jar;C:\Program Files\Java\jdk1.8.0_211\jre\classes;C:\Users\Zero\.ivy2\cache\org.scala-lang\scala-library\jars\scala-library-2.13.0.jar
[debug] 	-classpath
[debug] 	C:\Users\Zero\IdeaProjects\Scala\target\scala-2.13\classes;C:\Users\Zero\.ivy2\cache\com.typesafe.scala-logging\scala-logging_2.13\bundles\scala-logging_2.13-3.9.2.jar;C:\Users\Zero\.ivy2\cache\org.scala-lang\scala-reflect\jars\scala-reflect-2.13.0.jar;C:\Users\Zero\.ivy2\cache\org.slf4j\slf4j-api\jars\slf4j-api-1.7.26.jar;C:\Users\Zero\.ivy2\cache\joda-time\joda-time\jars\joda-time-2.10.4.jar;C:\Users\Zero\.ivy2\cache\org.joda\joda-convert\jars\joda-convert-2.2.1.jar;C:\Users\Zero\.ivy2\cache\org.devotionit\vantage-client\jars\vantage-client-0.0.2.jar;C:\Users\Zero\.ivy2\cache\org.eclipse.jetty\jetty-client\jars\jetty-client-9.4.15.v20190215.jar;C:\Users\Zero\.ivy2\cache\org.eclipse.jetty\jetty-http\jars\jetty-http-9.4.15.v20190215.jar;C:\Users\Zero\.ivy2\cache\org.eclipse.jetty\jetty-util\jars\jetty-util-9.4.15.v20190215.jar;C:\Users\Zero\.ivy2\cache\org.eclipse.jetty\jetty-io\jars\jetty-io-9.4.15.v20190215.jar;C:\Users\Zero\.ivy2\cache\com.fasterxml.jackson.core\jackson-databind\bundles\jackson-databind-2.9.8.jar;C:\Users\Zero\.ivy2\cache\com.fasterxml.jackson.core\jackson-annotations\bundles\jackson-annotations-2.9.0.jar;C:\Users\Zero\.ivy2\cache\com.fasterxml.jackson.core\jackson-core\bundles\jackson-core-2.9.8.jar;C:\Users\Zero\.ivy2\cache\com.fasterxml.jackson.datatype\jackson-datatype-jsr310\bundles\jackson-datatype-jsr310-2.9.8.jar;C:\Users\Zero\.ivy2\cache\org.apache.logging.log4j\log4j-api\jars\log4j-api-2.11.2.jar;C:\Users\Zero\.ivy2\cache\org.apache.logging.log4j\log4j-core\jars\log4j-core-2.11.2.jar;C:\Users\Zero\.ivy2\cache\org.apache.logging.log4j\log4j-slf4j-impl\jars\log4j-slf4j-impl-2.11.2.jar;C:\Users\Zero\.ivy2\cache\org.apache.commons\commons-lang3\jars\commons-lang3-3.8.1.jar;C:\Users\Zero\.ivy2\cache\org.projectlombok\lombok\jars\lombok-1.18.6.jar
[debug] Scala compilation took 31.888082031 s
[info] Done compiling.
[debug] Invalidating (transitively) by inheritance from com.local.ClassesAndObject.Abstract.HotelExtendsAbstract...
[debug] Initial set of included nodes: Set(com.local.ClassesAndObject.Abstract.HotelExtendsAbstract)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.ClassesAndObject.Abstract.HotelExtendsAbstract)
[debug] The following modified names cause invalidation of com.local.ClassesAndObject.Abstract.ClientExtendOfHotelAbstract: Set(UsedName(stats,[Default]), UsedName(HotelExtendsAbstract,[Default]), UsedName(com;local;ClassesAndObject;Abstract;HotelExtendsAbstract;init;,[Default]))
[debug] Change NamesChange(com.local.ClassesAndObject.Abstract.HotelExtendsAbstract,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(stats,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(HotelExtendsAbstract,[Default]), UsedName(com;local;ClassesAndObject;Abstract;HotelExtendsAbstract;init;,[Default]), UsedName(clone,[Default]), UsedName(notifyAll,[Default]))) invalidates 2 classes due to The com.local.ClassesAndObject.Abstract.HotelExtendsAbstract has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(stats,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(HotelExtendsAbstract,[Default]), UsedName(com;local;ClassesAndObject;Abstract;HotelExtendsAbstract;init;,[Default]), UsedName(clone,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.ClassesAndObject.Abstract.HotelExtendsAbstract)
[debug] 	> 
[debug] 	> by member reference: Set(com.local.ClassesAndObject.Abstract.ClientExtendOfHotelAbstract)
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Equity...
[debug] Initial set of included nodes: Set(com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Equity)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Equity)
[debug] The following modified names cause invalidation of com.local.ClassesAndObject.Covariance_TypeWithContraVariance.FinancialInstrumentTypeContraVariance: Set(UsedName(Equity,[Default]), UsedName(stat,[Default]))
[debug] The following modified names cause invalidation of com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Client_Covariance_Type: Set(UsedName(Equity,[Default]), UsedName(com;local;ClassesAndObject;Covariance_TypeWithContraVariance;Equity;init;,[Default]))
[debug] Change NamesChange(com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Equity,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(cost,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(copy$default$4,[Default]), UsedName(equals,[Default]), UsedName(quantity,[Default]), UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(hashCode,[Default]), UsedName(Equity,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(productElement,[Default]), UsedName(price,[Default]), UsedName(copy$default$1,[Default]), UsedName(com;local;ClassesAndObject;Covariance_TypeWithContraVariance;Equity;init;,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$3,[Default]), UsedName(copy,[Default]), UsedName(wait,[Default]), UsedName(stat,[Default]), UsedName(ticker,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(productElementNames,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(clone,[Default]), UsedName(productElementName,[Default]), UsedName(notifyAll,[Default]), UsedName(typeOfInstrument,[Default]), UsedName(productIterator,[Default]))) invalidates 3 classes due to The com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Equity has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(cost,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(copy$default$4,[Default]), UsedName(equals,[Default]), UsedName(quantity,[Default]), UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(hashCode,[Default]), UsedName(Equity,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(productElement,[Default]), UsedName(price,[Default]), UsedName(copy$default$1,[Default]), UsedName(com;local;ClassesAndObject;Covariance_TypeWithContraVariance;Equity;init;,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$3,[Default]), UsedName(copy,[Default]), UsedName(wait,[Default]), UsedName(stat,[Default]), UsedName(ticker,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(productElementNames,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(clone,[Default]), UsedName(productElementName,[Default]), UsedName(notifyAll,[Default]), UsedName(typeOfInstrument,[Default]), UsedName(productIterator,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Equity)
[debug] 	> 
[debug] 	> by member reference: Set(com.local.ClassesAndObject.Covariance_TypeWithContraVariance.FinancialInstrumentTypeContraVariance, com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Client_Covariance_Type)
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.ExistsFunc...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.ExistsFunc)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.ExistsFunc)
[debug] Change NamesChange(com.local.CollectionFunction.ExistsFunc,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(ExistsFunc,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(hotelExistPredicate,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(pfPredicate,[Default]), UsedName(hotels,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(hotelExist,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.ExistsFunc has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(ExistsFunc,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(hotelExistPredicate,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(pfPredicate,[Default]), UsedName(hotels,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(hotelExist,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.ExistsFunc)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.ClassesAndObject.Case.CaseHotel...
[debug] Initial set of included nodes: Set(com.local.ClassesAndObject.Case.CaseHotel)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.ClassesAndObject.Case.CaseHotel)
[debug] Change NamesChange(com.local.ClassesAndObject.Case.CaseHotel,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(CaseHotel,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(paperHotel,[Default]), UsedName(main,[Default]), UsedName(Hotel,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.ClassesAndObject.Case.CaseHotel has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(CaseHotel,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(paperHotel,[Default]), UsedName(main,[Default]), UsedName(Hotel,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.ClassesAndObject.Case.CaseHotel)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.TraitTraining.HotelFactory.Hotels...
[debug] Initial set of included nodes: Set(com.local.TraitTraining.HotelFactory.Hotels)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.TraitTraining.HotelFactory.Hotels)
[debug] The following modified names cause invalidation of com.local.TraitTraining.HotelFactory.HotelFactory: Set(UsedName(FeatherFactoryHotel,[Default]), UsedName(PaperFactoryHotel,[Default]), UsedName(OtherHotels,[Default]), UsedName(Hotel,[Default]), UsedName(Hotels,[Default]))
[debug] The following modified names cause invalidation of com.local.TraitTraining.HotelFactory.Client: Set(UsedName(Hotel,[Default]), UsedName(Hotels,[Default]))
[debug] Change NamesChange(com.local.TraitTraining.HotelFactory.Hotels,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(FeatherFactoryHotel,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(clone,[Default]), UsedName(PaperFactoryHotel,[Default]), UsedName(OtherHotels,[Default]), UsedName(Hotel,[Default]), UsedName(notifyAll,[Default]), UsedName(Hotels,[Default]))) invalidates 3 classes due to The com.local.TraitTraining.HotelFactory.Hotels has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(FeatherFactoryHotel,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(clone,[Default]), UsedName(PaperFactoryHotel,[Default]), UsedName(OtherHotels,[Default]), UsedName(Hotel,[Default]), UsedName(notifyAll,[Default]), UsedName(Hotels,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.TraitTraining.HotelFactory.Hotels)
[debug] 	> 
[debug] 	> by member reference: Set(com.local.TraitTraining.HotelFactory.HotelFactory, com.local.TraitTraining.HotelFactory.Client)
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.ForEachFunc...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.ForEachFunc)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.ForEachFunc)
[debug] Change NamesChange(com.local.CollectionFunction.ForEachFunc,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(ForEachFunc,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(lowerCase,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(bxStock,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(strStock,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(emptySeq,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.ForEachFunc has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(ForEachFunc,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(lowerCase,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(bxStock,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(strStock,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(emptySeq,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.ForEachFunc)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.MaxByFunc.Stock...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.MaxByFunc.Stock)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.MaxByFunc.Stock)
[debug] Change NamesChange(com.local.CollectionFunction.MaxByFunc.Stock,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(Stock,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(apply,[Default]), UsedName(notify,[Default]), UsedName(unapply,[Default]), UsedName(curried,[Default]), UsedName(productElement,[Default]), UsedName(price,[Default]), UsedName(copy$default$1,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy,[Default]), UsedName(wait,[Default]), UsedName(ticker,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(productElementNames,[Default]), UsedName(toString,[Default]), UsedName(tupled,[Default]), UsedName(!=,[Default]), UsedName(com;local;CollectionFunction;MaxByFunc;Stock;init;,[Default]), UsedName(productArity,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(clone,[Default]), UsedName(productElementName,[Default]), UsedName(notifyAll,[Default]), UsedName(productIterator,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.MaxByFunc.Stock has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(Stock,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(apply,[Default]), UsedName(notify,[Default]), UsedName(unapply,[Default]), UsedName(curried,[Default]), UsedName(productElement,[Default]), UsedName(price,[Default]), UsedName(copy$default$1,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy,[Default]), UsedName(wait,[Default]), UsedName(ticker,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(productElementNames,[Default]), UsedName(toString,[Default]), UsedName(tupled,[Default]), UsedName(!=,[Default]), UsedName(com;local;CollectionFunction;MaxByFunc;Stock;init;,[Default]), UsedName(productArity,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(clone,[Default]), UsedName(productElementName,[Default]), UsedName(notifyAll,[Default]), UsedName(productIterator,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.MaxByFunc.Stock)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.ClassesAndObject.Type_Aliasing.TypeAliasVsCaseClassHotel...
[debug] Initial set of included nodes: Set(com.local.ClassesAndObject.Type_Aliasing.TypeAliasVsCaseClassHotel)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.ClassesAndObject.Type_Aliasing.TypeAliasVsCaseClassHotel)
[debug] Change NamesChange(com.local.ClassesAndObject.Type_Aliasing.TypeAliasVsCaseClassHotel,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(displayDetail,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(ZHotel,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(featherHotelTupele,[Default]), UsedName(executionStart,[Default]), UsedName(HotelType,[Default]), UsedName(hotelTuple,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(hotel2,[Default]), UsedName(TypeAliasVsCaseClassHotel,[Default]), UsedName(hotel,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(hotel3,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(seqHotels,[Default]), UsedName(main,[Default]), UsedName(PaperHotel,[Default]), UsedName(Hotel,[Default]), UsedName(notifyAll,[Default]), UsedName(featherHotel,[Default]))) invalidates 1 classes due to The com.local.ClassesAndObject.Type_Aliasing.TypeAliasVsCaseClassHotel has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(displayDetail,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(ZHotel,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(featherHotelTupele,[Default]), UsedName(executionStart,[Default]), UsedName(HotelType,[Default]), UsedName(hotelTuple,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(hotel2,[Default]), UsedName(TypeAliasVsCaseClassHotel,[Default]), UsedName(hotel,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(hotel3,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(seqHotels,[Default]), UsedName(main,[Default]), UsedName(PaperHotel,[Default]), UsedName(Hotel,[Default]), UsedName(notifyAll,[Default]), UsedName(featherHotel,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.ClassesAndObject.Type_Aliasing.TypeAliasVsCaseClassHotel)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.GroupByFunc.Stock...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.GroupByFunc.Stock)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.GroupByFunc.Stock)
[debug] Change NamesChange(com.local.CollectionFunction.GroupByFunc.Stock,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(Stock,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(apply,[Default]), UsedName(notify,[Default]), UsedName(unapply,[Default]), UsedName(curried,[Default]), UsedName(productElement,[Default]), UsedName(copy$default$1,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy,[Default]), UsedName(wait,[Default]), UsedName(ticker,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(productElementNames,[Default]), UsedName(toString,[Default]), UsedName(tupled,[Default]), UsedName(!=,[Default]), UsedName(dailyPrice,[Default]), UsedName(com;local;CollectionFunction;GroupByFunc;Stock;init;,[Default]), UsedName(productArity,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(clone,[Default]), UsedName(productElementName,[Default]), UsedName(notifyAll,[Default]), UsedName(productIterator,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.GroupByFunc.Stock has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(Stock,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(apply,[Default]), UsedName(notify,[Default]), UsedName(unapply,[Default]), UsedName(curried,[Default]), UsedName(productElement,[Default]), UsedName(copy$default$1,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy,[Default]), UsedName(wait,[Default]), UsedName(ticker,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(productElementNames,[Default]), UsedName(toString,[Default]), UsedName(tupled,[Default]), UsedName(!=,[Default]), UsedName(dailyPrice,[Default]), UsedName(com;local;CollectionFunction;GroupByFunc;Stock;init;,[Default]), UsedName(productArity,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(clone,[Default]), UsedName(productElementName,[Default]), UsedName(notifyAll,[Default]), UsedName(productIterator,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.GroupByFunc.Stock)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.UnZipFunc...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.UnZipFunc)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.UnZipFunc)
[debug] Change NamesChange(com.local.CollectionFunction.UnZipFunc,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(unZipHotelNamePrice,[Default]), UsedName(hotel,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(hotelPrice,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(hotelNamePrice,[Default]), UsedName($init$,[Default]), UsedName(UnZipFunc,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.UnZipFunc has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(unZipHotelNamePrice,[Default]), UsedName(hotel,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(hotelPrice,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(hotelNamePrice,[Default]), UsedName($init$,[Default]), UsedName(UnZipFunc,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.UnZipFunc)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.TraitTraining.ExtMultiTraits.Bond...
[debug] Initial set of included nodes: Set(com.local.TraitTraining.ExtMultiTraits.Bond)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.TraitTraining.ExtMultiTraits.Bond)
[debug] The following modified names cause invalidation of com.local.TraitTraining.ExtMultiTraits.Client: Set(UsedName(com;local;TraitTraining;ExtMultiTraits;Bond;init;,[Default]), UsedName(Bond,[Default]), UsedName(stats,[Default]))
[debug] Change NamesChange(com.local.TraitTraining.ExtMultiTraits.Bond,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isActive,[Default]), UsedName(notify,[Default]), UsedName(identifier,[Default]), UsedName(productElement,[Default]), UsedName(price,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(com;local;TraitTraining;ExtMultiTraits;Bond;init;,[Default]), UsedName(productElementNames,[Default]), UsedName(Bond,[Default]), UsedName(stats,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(clone,[Default]), UsedName(productElementName,[Default]), UsedName(notifyAll,[Default]), UsedName(productIterator,[Default]))) invalidates 2 classes due to The com.local.TraitTraining.ExtMultiTraits.Bond has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isActive,[Default]), UsedName(notify,[Default]), UsedName(identifier,[Default]), UsedName(productElement,[Default]), UsedName(price,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(com;local;TraitTraining;ExtMultiTraits;Bond;init;,[Default]), UsedName(productElementNames,[Default]), UsedName(Bond,[Default]), UsedName(stats,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(clone,[Default]), UsedName(productElementName,[Default]), UsedName(notifyAll,[Default]), UsedName(productIterator,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.TraitTraining.ExtMultiTraits.Bond)
[debug] 	> 
[debug] 	> by member reference: Set(com.local.TraitTraining.ExtMultiTraits.Client)
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.TraitTraining.ExTrait.Client...
[debug] Initial set of included nodes: Set(com.local.TraitTraining.ExTrait.Client)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.TraitTraining.ExTrait.Client)
[debug] Change NamesChange(com.local.TraitTraining.ExTrait.Client,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(buy,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(equityBX,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(Client,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.TraitTraining.ExTrait.Client has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(buy,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(equityBX,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(Client,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.TraitTraining.ExTrait.Client)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.ClassesAndObject.Typed_Class.TypeHotels...
[debug] Initial set of included nodes: Set(com.local.ClassesAndObject.Typed_Class.TypeHotels)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.ClassesAndObject.Typed_Class.TypeHotels)
[debug] The following modified names cause invalidation of com.local.ClassesAndObject.Typed_Class.TypedClient: Set(UsedName(TypeHotels,[Default]), UsedName(printHotel,[Default]), UsedName(com;local;ClassesAndObject;Typed_Class;TypeHotels;init;,[Default]))
[debug] Change NamesChange(com.local.ClassesAndObject.Typed_Class.TypeHotels,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(TypeHotels,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(printHotel,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(clone,[Default]), UsedName(com;local;ClassesAndObject;Typed_Class;TypeHotels;init;,[Default]), UsedName(notifyAll,[Default]))) invalidates 2 classes due to The com.local.ClassesAndObject.Typed_Class.TypeHotels has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(TypeHotels,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(printHotel,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(clone,[Default]), UsedName(com;local;ClassesAndObject;Typed_Class;TypeHotels;init;,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.ClassesAndObject.Typed_Class.TypeHotels)
[debug] 	> 
[debug] 	> by member reference: Set(com.local.ClassesAndObject.Typed_Class.TypedClient)
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.SortByFunc.Hotel...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.SortByFunc.Hotel)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.SortByFunc.Hotel)
[debug] Change NamesChange(com.local.CollectionFunction.SortByFunc.Hotel,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(apply,[Default]), UsedName(notify,[Default]), UsedName(unapply,[Default]), UsedName(curried,[Default]), UsedName(productElement,[Default]), UsedName(price,[Default]), UsedName(copy$default$1,[Default]), UsedName(name,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy,[Default]), UsedName(wait,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(productElementNames,[Default]), UsedName(com;local;CollectionFunction;SortByFunc;Hotel;init;,[Default]), UsedName(toString,[Default]), UsedName(tupled,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(clone,[Default]), UsedName(productElementName,[Default]), UsedName(Hotel,[Default]), UsedName(notifyAll,[Default]), UsedName(productIterator,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.SortByFunc.Hotel has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(apply,[Default]), UsedName(notify,[Default]), UsedName(unapply,[Default]), UsedName(curried,[Default]), UsedName(productElement,[Default]), UsedName(price,[Default]), UsedName(copy$default$1,[Default]), UsedName(name,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy,[Default]), UsedName(wait,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(productElementNames,[Default]), UsedName(com;local;CollectionFunction;SortByFunc;Hotel;init;,[Default]), UsedName(toString,[Default]), UsedName(tupled,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(clone,[Default]), UsedName(productElementName,[Default]), UsedName(Hotel,[Default]), UsedName(notifyAll,[Default]), UsedName(productIterator,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.SortByFunc.Hotel)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.HotelAttributes.package...
[debug] Initial set of included nodes: Set(com.local.HotelAttributes.package)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.HotelAttributes.package)
[debug] Change NamesChange(com.local.HotelAttributes.package,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(DateTime,[Default]), UsedName(ne,[Default]), UsedName(AugmentedHotel,[Implicit]), UsedName(package,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(clone,[Default]), UsedName(Hotel,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.HotelAttributes.package has the following implicit definitions changed:
[debug] 	UsedName(AugmentedHotel,[Implicit]).
[debug] 	> by transitive inheritance: Set(com.local.HotelAttributes.package)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.com.projects.financial.Stock...
[debug] Initial set of included nodes: Set(com.com.projects.financial.Stock)
[debug] Invalidated by transitive inheritance dependency: Set(com.com.projects.financial.Stock)
[debug] Change NamesChange(com.com.projects.financial.Stock,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(Stock,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(corporation,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(productElement,[Default]), UsedName(copy$default$1,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$3,[Default]), UsedName(copy,[Default]), UsedName(wait,[Default]), UsedName(ticker,[Default]), UsedName(com;com;projects;financial;Stock;init;,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(productElementNames,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(prices,[Default]), UsedName(productArity,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(clone,[Default]), UsedName(productElementName,[Default]), UsedName(notifyAll,[Default]), UsedName(productIterator,[Default]))) invalidates 1 classes due to The com.com.projects.financial.Stock has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(Stock,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(corporation,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(productElement,[Default]), UsedName(copy$default$1,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$3,[Default]), UsedName(copy,[Default]), UsedName(wait,[Default]), UsedName(ticker,[Default]), UsedName(com;com;projects;financial;Stock;init;,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(productElementNames,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(prices,[Default]), UsedName(productArity,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(clone,[Default]), UsedName(productElementName,[Default]), UsedName(notifyAll,[Default]), UsedName(productIterator,[Default]).
[debug] 	> by transitive inheritance: Set(com.com.projects.financial.Stock)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.FoldFunc...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.FoldFunc)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.FoldFunc)
[debug] Change NamesChange(com.local.CollectionFunction.FoldFunc,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(FoldFunc,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(priceBx,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(seqStocks,[Default]), UsedName(ne,[Default]), UsedName(sumOfStockPrice,[Default]), UsedName(tickerConcatenate,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.FoldFunc has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(FoldFunc,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(priceBx,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(seqStocks,[Default]), UsedName(ne,[Default]), UsedName(sumOfStockPrice,[Default]), UsedName(tickerConcatenate,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.FoldFunc)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.FlattenFunc...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.FlattenFunc)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.FlattenFunc)
[debug] Change NamesChange(com.local.CollectionFunction.FlattenFunc,ModifiedNames(changes = UsedName(typeCorporateBond,[Default]), UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(typeBond,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(appendToBond,[Default]), UsedName(executionStart,[Default]), UsedName(FlattenFunc,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(seqBond,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(flatBond,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.FlattenFunc has the following regular definitions changed:
[debug] 	UsedName(typeCorporateBond,[Default]), UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(typeBond,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(appendToBond,[Default]), UsedName(executionStart,[Default]), UsedName(FlattenFunc,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(seqBond,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(flatBond,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.FlattenFunc)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.DropFunc...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.DropFunc)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.DropFunc)
[debug] Change NamesChange(com.local.CollectionFunction.DropFunc,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(dropInfiniti,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(DropFunc,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(autoBrands,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.DropFunc has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(dropInfiniti,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(DropFunc,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(autoBrands,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.DropFunc)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.SizeFunc...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.SizeFunc)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.SizeFunc)
[debug] Change NamesChange(com.local.CollectionFunction.SizeFunc,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(SizeFunc,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(hotel,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]), UsedName(sizeHotel,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.SizeFunc has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(SizeFunc,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(hotel,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]), UsedName(sizeHotel,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.SizeFunc)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.TraitTraining.TypeParameters.Equities...
[debug] Initial set of included nodes: Set(com.local.TraitTraining.TypeParameters.Equities)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.TraitTraining.TypeParameters.Equities)
[debug] The following modified names cause invalidation of com.local.TraitTraining.TypeParameters.Client: Set(UsedName(com;local;TraitTraining;TypeParameters;Equities;init;,[Default]), UsedName(Equities,[Default]))
[debug] Change NamesChange(com.local.TraitTraining.TypeParameters.Equities,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(getLengthOfContract,[Default]), UsedName(com;local;TraitTraining;TypeParameters;Equities;init;,[Default]), UsedName(ne,[Default]), UsedName(Equities,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(time,[Default]), UsedName(getTypeOfContract,[Default]), UsedName(clone,[Default]), UsedName(desc,[Default]), UsedName(notifyAll,[Default]))) invalidates 2 classes due to The com.local.TraitTraining.TypeParameters.Equities has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(getLengthOfContract,[Default]), UsedName(com;local;TraitTraining;TypeParameters;Equities;init;,[Default]), UsedName(ne,[Default]), UsedName(Equities,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(time,[Default]), UsedName(getTypeOfContract,[Default]), UsedName(clone,[Default]), UsedName(desc,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.TraitTraining.TypeParameters.Equities)
[debug] 	> 
[debug] 	> by member reference: Set(com.local.TraitTraining.TypeParameters.Client)
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.ImmutableCollection.ListCollection.ListCollection...
[debug] Initial set of included nodes: Set(com.local.ImmutableCollection.ListCollection.ListCollection)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.ImmutableCollection.ListCollection.ListCollection)
[debug] Change NamesChange(com.local.ImmutableCollection.ListCollection.ListCollection,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(stockList,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(stockListUpdateLast,[Default]), UsedName(goldmanSach,[Default]), UsedName(hashCode,[Default]), UsedName(frontAddList,[Default]), UsedName(BOFA,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(consultingStockList,[Default]), UsedName(queryList,[Default]), UsedName(notify,[Default]), UsedName(firstAppendList,[Default]), UsedName(stockListUpdate,[Default]), UsedName(executionStart,[Default]), UsedName(lastAppendList,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ListCollection,[Default]), UsedName(lastAddList,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(emptyStock,[Default]), UsedName(toString,[Default]), UsedName(stockListFirst,[Default]), UsedName(!=,[Default]), UsedName(stocklistLast,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(ifCitiExist,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.ImmutableCollection.ListCollection.ListCollection has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(stockList,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(stockListUpdateLast,[Default]), UsedName(goldmanSach,[Default]), UsedName(hashCode,[Default]), UsedName(frontAddList,[Default]), UsedName(BOFA,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(consultingStockList,[Default]), UsedName(queryList,[Default]), UsedName(notify,[Default]), UsedName(firstAppendList,[Default]), UsedName(stockListUpdate,[Default]), UsedName(executionStart,[Default]), UsedName(lastAppendList,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ListCollection,[Default]), UsedName(lastAddList,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(emptyStock,[Default]), UsedName(toString,[Default]), UsedName(stockListFirst,[Default]), UsedName(!=,[Default]), UsedName(stocklistLast,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(ifCitiExist,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.ImmutableCollection.ListCollection.ListCollection)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.MapFunc...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.MapFunc)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.MapFunc)
[debug] Change NamesChange(com.local.CollectionFunction.MapFunc,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(hotelsRemoteStr,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(hotels2,[Default]), UsedName(removeHotel,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(MapFunc,[Default]), UsedName(addHotelStr,[Default]), UsedName(hotels,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(anyRefHotels,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.MapFunc has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(hotelsRemoteStr,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(hotels2,[Default]), UsedName(removeHotel,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(MapFunc,[Default]), UsedName(addHotelStr,[Default]), UsedName(hotels,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(anyRefHotels,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.MapFunc)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.TraitTraining.ExTrait.Extend_Trait_Equity...
[debug] Initial set of included nodes: Set(com.local.TraitTraining.ExTrait.Extend_Trait_Equity)
[debug] Including com.local.TraitTraining.ExTrait.Equity by com.local.TraitTraining.ExTrait.Extend_Trait_Equity
[debug] Invalidated by transitive inheritance dependency: Set(com.local.TraitTraining.ExTrait.Extend_Trait_Equity, com.local.TraitTraining.ExTrait.Equity)
[debug] The following modified names cause invalidation of com.local.TraitTraining.ExTrait.Equity: Set(UsedName(asInstanceOf,[Default]), UsedName(eq,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(buy,[Default]), UsedName(sell,[Default]), UsedName(Extend_Trait_Equity,[Default]), UsedName(hold,[Default]))
[debug] The following modified names cause invalidation of com.local.TraitTraining.ExTrait.Client: Set(UsedName(buy,[Default]))
[debug] Change NamesChange(com.local.TraitTraining.ExTrait.Extend_Trait_Equity,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(buy,[Default]), UsedName(notify,[Default]), UsedName(sell,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(Extend_Trait_Equity,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(clone,[Default]), UsedName(hold,[Default]), UsedName(notifyAll,[Default]))) invalidates 3 classes due to The com.local.TraitTraining.ExTrait.Extend_Trait_Equity has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(buy,[Default]), UsedName(notify,[Default]), UsedName(sell,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(Extend_Trait_Equity,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(clone,[Default]), UsedName(hold,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.TraitTraining.ExTrait.Extend_Trait_Equity, com.local.TraitTraining.ExTrait.Equity)
[debug] 	> 
[debug] 	> by member reference: Set(com.local.TraitTraining.ExTrait.Equity, com.local.TraitTraining.ExTrait.Client)
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.SliceFunc...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.SliceFunc)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.SliceFunc)
[debug] Change NamesChange(com.local.CollectionFunction.SliceFunc,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(first3IndexofTicker,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(SliceFunc,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ticker,[Default]), UsedName(ne,[Default]), UsedName(firstIndexOfTicker,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(index1to3IndexofTicker,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(first2IndexofTicker,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.SliceFunc has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(first3IndexofTicker,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(SliceFunc,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ticker,[Default]), UsedName(ne,[Default]), UsedName(firstIndexOfTicker,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(index1to3IndexofTicker,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(first2IndexofTicker,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.SliceFunc)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.HotelAttributes.Hotel...
[debug] Initial set of included nodes: Set(com.local.HotelAttributes.Hotel)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.HotelAttributes.Hotel)
[debug] Change NamesChange(com.local.HotelAttributes.Hotel,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(apply,[Default]), UsedName(notify,[Default]), UsedName(unapply,[Default]), UsedName(location,[Default]), UsedName(curried,[Default]), UsedName(com;local;HotelAttributes;Hotel;init;,[Default]), UsedName(productElement,[Default]), UsedName(copy$default$1,[Default]), UsedName(name,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$3,[Default]), UsedName(copy,[Default]), UsedName(wait,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(productElementNames,[Default]), UsedName(costPerNight,[Default]), UsedName(toString,[Default]), UsedName(tupled,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName(<init>$default$3,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(clone,[Default]), UsedName(productElementName,[Default]), UsedName(apply$default$3,[Default]), UsedName(Hotel,[Default]), UsedName(notifyAll,[Default]), UsedName(productIterator,[Default]))) invalidates 1 classes due to The com.local.HotelAttributes.Hotel has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(apply,[Default]), UsedName(notify,[Default]), UsedName(unapply,[Default]), UsedName(location,[Default]), UsedName(curried,[Default]), UsedName(com;local;HotelAttributes;Hotel;init;,[Default]), UsedName(productElement,[Default]), UsedName(copy$default$1,[Default]), UsedName(name,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$3,[Default]), UsedName(copy,[Default]), UsedName(wait,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(productElementNames,[Default]), UsedName(costPerNight,[Default]), UsedName(toString,[Default]), UsedName(tupled,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName(<init>$default$3,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(clone,[Default]), UsedName(productElementName,[Default]), UsedName(apply$default$3,[Default]), UsedName(Hotel,[Default]), UsedName(notifyAll,[Default]), UsedName(productIterator,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.HotelAttributes.Hotel)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.MutableCollection.ArrayCollection...
[debug] Initial set of included nodes: Set(com.local.MutableCollection.ArrayCollection)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.MutableCollection.ArrayCollection)
[debug] Change NamesChange(com.local.MutableCollection.ArrayCollection,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(counterArray,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(rangeArray,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(ArrayCollection,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(blackstoneValue,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(cloneArray,[Default]), UsedName(testIfArrayAreEqual,[Default]), UsedName(wait,[Default]), UsedName(copyOfRangeArray,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(stockAutoArray,[Default]), UsedName(mergeArray,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(stockFinanceArray,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.MutableCollection.ArrayCollection has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(counterArray,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(rangeArray,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(ArrayCollection,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(blackstoneValue,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(cloneArray,[Default]), UsedName(testIfArrayAreEqual,[Default]), UsedName(wait,[Default]), UsedName(copyOfRangeArray,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(stockAutoArray,[Default]), UsedName(mergeArray,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(stockFinanceArray,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.MutableCollection.ArrayCollection)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.TraitTraining.ExtMultiTraits.SecurityConversion...
[debug] Initial set of included nodes: Set(com.local.TraitTraining.ExtMultiTraits.SecurityConversion)
[debug] Including com.local.TraitTraining.ExtMultiTraits.Trade by com.local.TraitTraining.ExtMultiTraits.SecurityConversion
[debug] Invalidated by transitive inheritance dependency: Set(com.local.TraitTraining.ExtMultiTraits.SecurityConversion, com.local.TraitTraining.ExtMultiTraits.Trade)
[debug] The following modified names cause invalidation of com.local.TraitTraining.ExtMultiTraits.Trade: Set(UsedName(SecurityConversion,[Default]))
[debug] The following modified names cause invalidation of com.local.TraitTraining.ExtMultiTraits.Client: Set(UsedName(convertSecurity,[Default]))
[debug] Change NamesChange(com.local.TraitTraining.ExtMultiTraits.SecurityConversion,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(SecurityConversion,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(clone,[Default]), UsedName(convertSecurity,[Default]), UsedName(notifyAll,[Default]))) invalidates 3 classes due to The com.local.TraitTraining.ExtMultiTraits.SecurityConversion has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(SecurityConversion,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(clone,[Default]), UsedName(convertSecurity,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.TraitTraining.ExtMultiTraits.SecurityConversion, com.local.TraitTraining.ExtMultiTraits.Trade)
[debug] 	> 
[debug] 	> by member reference: Set(com.local.TraitTraining.ExtMultiTraits.Trade, com.local.TraitTraining.ExtMultiTraits.Client)
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.ImmutableCollection.SequenceCollection.SequenceCollection...
[debug] Initial set of included nodes: Set(com.local.ImmutableCollection.SequenceCollection.SequenceCollection)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.ImmutableCollection.SequenceCollection.SequenceCollection)
[debug] Change NamesChange(com.local.ImmutableCollection.SequenceCollection.SequenceCollection,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(addHotel,[Default]), UsedName(hotelFullSeq,[Default]), UsedName(hotels,[Default]), UsedName(ne,[Default]), UsedName(emptyHotelSeq,[Default]), UsedName(SequenceCollection,[Default]), UsedName(hotelSeq,[Default]), UsedName(toString,[Default]), UsedName(hiltonHotel,[Default]), UsedName(!=,[Default]), UsedName(gbh,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.ImmutableCollection.SequenceCollection.SequenceCollection has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(addHotel,[Default]), UsedName(hotelFullSeq,[Default]), UsedName(hotels,[Default]), UsedName(ne,[Default]), UsedName(emptyHotelSeq,[Default]), UsedName(SequenceCollection,[Default]), UsedName(hotelSeq,[Default]), UsedName(toString,[Default]), UsedName(hiltonHotel,[Default]), UsedName(!=,[Default]), UsedName(gbh,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.ImmutableCollection.SequenceCollection.SequenceCollection)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.MaxByFunc...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.MaxByFunc)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.MaxByFunc)
[debug] Change NamesChange(com.local.CollectionFunction.MaxByFunc,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(Stock,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(MaxByFunc,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(stockPriceVF,[Default]), UsedName(findMaxStockPrice,[Default]), UsedName(findMaxStockPriceWithVF,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(stockSeq,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.MaxByFunc has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(Stock,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(MaxByFunc,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(stockPriceVF,[Default]), UsedName(findMaxStockPrice,[Default]), UsedName(findMaxStockPriceWithVF,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(stockSeq,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.MaxByFunc)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.ClassesAndObject.Covariance_TypeWithContraVariance.FinancialInstrumentTypeContraVariance...
[debug] Initial set of included nodes: Set(com.local.ClassesAndObject.Covariance_TypeWithContraVariance.FinancialInstrumentTypeContraVariance)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.ClassesAndObject.Covariance_TypeWithContraVariance.FinancialInstrumentTypeContraVariance)
[debug] The following modified names cause invalidation of com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Client_Covariance_Type: Set(UsedName(printStats,[Default]), UsedName(com;local;ClassesAndObject;Covariance_TypeWithContraVariance;FinancialInstrumentTypeContraVariance;init;,[Default]), UsedName(FinancialInstrumentTypeContraVariance,[Default]))
[debug] Change NamesChange(com.local.ClassesAndObject.Covariance_TypeWithContraVariance.FinancialInstrumentTypeContraVariance,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(printStats,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(com;local;ClassesAndObject;Covariance_TypeWithContraVariance;FinancialInstrumentTypeContraVariance;init;,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(FinancialInstrumentTypeContraVariance,[Default]), UsedName(clone,[Default]), UsedName(notifyAll,[Default]))) invalidates 2 classes due to The com.local.ClassesAndObject.Covariance_TypeWithContraVariance.FinancialInstrumentTypeContraVariance has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(printStats,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(com;local;ClassesAndObject;Covariance_TypeWithContraVariance;FinancialInstrumentTypeContraVariance;init;,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(FinancialInstrumentTypeContraVariance,[Default]), UsedName(clone,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.ClassesAndObject.Covariance_TypeWithContraVariance.FinancialInstrumentTypeContraVariance)
[debug] 	> 
[debug] 	> by member reference: Set(com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Client_Covariance_Type)
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.HeadWithLastFunc...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.HeadWithLastFunc)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.HeadWithLastFunc)
[debug] Change NamesChange(com.local.CollectionFunction.HeadWithLastFunc,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(HeadWithLastFunc,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(lastIndex,[Default]), UsedName(executionStart,[Default]), UsedName(headHotel,[Default]), UsedName(alternativeIndex,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(hotel,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(alternativeHead,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.HeadWithLastFunc has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(HeadWithLastFunc,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(lastIndex,[Default]), UsedName(executionStart,[Default]), UsedName(headHotel,[Default]), UsedName(alternativeIndex,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(hotel,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(alternativeHead,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.HeadWithLastFunc)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.ImmutableCollection.StreamCollection.StreamCollection...
[debug] Initial set of included nodes: Set(com.local.ImmutableCollection.StreamCollection.StreamCollection)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.ImmutableCollection.StreamCollection.StreamCollection)
[debug] Change NamesChange(com.local.ImmutableCollection.StreamCollection.StreamCollection,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(counterStream2,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(stockStream,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(StreamCollection,[Default]), UsedName(LazyList,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(counterStream,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.ImmutableCollection.StreamCollection.StreamCollection has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(counterStream2,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(stockStream,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(StreamCollection,[Default]), UsedName(LazyList,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(counterStream,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.ImmutableCollection.StreamCollection.StreamCollection)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.review.Basic.ForControl.Stock...
[debug] Initial set of included nodes: Set(com.review.Basic.ForControl.Stock)
[debug] Invalidated by transitive inheritance dependency: Set(com.review.Basic.ForControl.Stock)
[debug] Change NamesChange(com.review.Basic.ForControl.Stock,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(Stock,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(apply,[Default]), UsedName(notify,[Default]), UsedName(unapply,[Default]), UsedName(curried,[Default]), UsedName(productElement,[Default]), UsedName(price,[Default]), UsedName(copy$default$1,[Default]), UsedName(name,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$3,[Default]), UsedName(copy,[Default]), UsedName(wait,[Default]), UsedName(ticker,[Default]), UsedName(com;review;Basic;ForControl;Stock;init;,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(productElementNames,[Default]), UsedName(toString,[Default]), UsedName(tupled,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(clone,[Default]), UsedName(productElementName,[Default]), UsedName(notifyAll,[Default]), UsedName(productIterator,[Default]))) invalidates 1 classes due to The com.review.Basic.ForControl.Stock has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(Stock,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(apply,[Default]), UsedName(notify,[Default]), UsedName(unapply,[Default]), UsedName(curried,[Default]), UsedName(productElement,[Default]), UsedName(price,[Default]), UsedName(copy$default$1,[Default]), UsedName(name,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$3,[Default]), UsedName(copy,[Default]), UsedName(wait,[Default]), UsedName(ticker,[Default]), UsedName(com;review;Basic;ForControl;Stock;init;,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(productElementNames,[Default]), UsedName(toString,[Default]), UsedName(tupled,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(clone,[Default]), UsedName(productElementName,[Default]), UsedName(notifyAll,[Default]), UsedName(productIterator,[Default]).
[debug] 	> by transitive inheritance: Set(com.review.Basic.ForControl.Stock)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.ClassesAndObject.clientHotelCompanionWithFactory...
[debug] Initial set of included nodes: Set(com.local.ClassesAndObject.clientHotelCompanionWithFactory)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.ClassesAndObject.clientHotelCompanionWithFactory)
[debug] Change NamesChange(com.local.ClassesAndObject.clientHotelCompanionWithFactory,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(airbnb,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(motel,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(clientHotelCompanionWithFactory,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.ClassesAndObject.clientHotelCompanionWithFactory has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(airbnb,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(motel,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(clientHotelCompanionWithFactory,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.ClassesAndObject.clientHotelCompanionWithFactory)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.ImmutableCollection.VectorCollection.VectorCollection...
[debug] Initial set of included nodes: Set(com.local.ImmutableCollection.VectorCollection.VectorCollection)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.ImmutableCollection.VectorCollection.VectorCollection)
[debug] Change NamesChange(com.local.ImmutableCollection.VectorCollection.VectorCollection,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(VectorCollection,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(addGuestHotel,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(addingVectors,[Default]), UsedName(wait,[Default]), UsedName(singleGuestHotel,[Default]), UsedName(ne,[Default]), UsedName(guestHotel,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(emptyVector,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(reyesHilton,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.ImmutableCollection.VectorCollection.VectorCollection has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(VectorCollection,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(addGuestHotel,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(addingVectors,[Default]), UsedName(wait,[Default]), UsedName(singleGuestHotel,[Default]), UsedName(ne,[Default]), UsedName(guestHotel,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(emptyVector,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(reyesHilton,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.ImmutableCollection.VectorCollection.VectorCollection)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.TraitTraining.TypeParameters.Securities...
[debug] Initial set of included nodes: Set(com.local.TraitTraining.TypeParameters.Securities)
[debug] Including com.local.TraitTraining.TypeParameters.FixedIncome by com.local.TraitTraining.TypeParameters.Securities
[debug] Including com.local.TraitTraining.TypeParameters.Equities by com.local.TraitTraining.TypeParameters.Securities
[debug] Invalidated by transitive inheritance dependency: Set(com.local.TraitTraining.TypeParameters.Equities, com.local.TraitTraining.TypeParameters.FixedIncome, com.local.TraitTraining.TypeParameters.Securities)
[debug] The following modified names cause invalidation of com.local.TraitTraining.TypeParameters.Client: Set(UsedName(Securities,[Default]))
[debug] The following modified names cause invalidation of com.local.TraitTraining.TypeParameters.Client: Set(UsedName(Securities,[Default]))
[debug] The following modified names cause invalidation of com.local.TraitTraining.TypeParameters.FixedIncome: Set(UsedName(com;local;TraitTraining;TypeParameters;Securities;init;,[Default]), UsedName(Securities,[Default]))
[debug] The following modified names cause invalidation of com.local.TraitTraining.TypeParameters.Trade: Set(UsedName(Securities,[Default]), UsedName(==,[Default]), UsedName(getTypeOfContract,[Default]), UsedName(desc,[Default]))
[debug] The following modified names cause invalidation of com.local.TraitTraining.TypeParameters.Equities: Set(UsedName(com;local;TraitTraining;TypeParameters;Securities;init;,[Default]), UsedName(Securities,[Default]))
[debug] The following modified names cause invalidation of com.local.TraitTraining.TypeParameters.Client: Set(UsedName(Securities,[Default]))
[debug] Change NamesChange(com.local.TraitTraining.TypeParameters.Securities,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(com;local;TraitTraining;TypeParameters;Securities;init;,[Default]), UsedName(hashCode,[Default]), UsedName(Securities,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(getLengthOfContract,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(getTypeOfContract,[Default]), UsedName(clone,[Default]), UsedName(desc,[Default]), UsedName(notifyAll,[Default]))) invalidates 5 classes due to The com.local.TraitTraining.TypeParameters.Securities has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(com;local;TraitTraining;TypeParameters;Securities;init;,[Default]), UsedName(hashCode,[Default]), UsedName(Securities,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(getLengthOfContract,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(getTypeOfContract,[Default]), UsedName(clone,[Default]), UsedName(desc,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.TraitTraining.TypeParameters.Equities, com.local.TraitTraining.TypeParameters.FixedIncome, com.local.TraitTraining.TypeParameters.Securities)
[debug] 	> 
[debug] 	> by member reference: Set(com.local.TraitTraining.TypeParameters.Client, com.local.TraitTraining.TypeParameters.FixedIncome, com.local.TraitTraining.TypeParameters.Trade, com.local.TraitTraining.TypeParameters.Equities)
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.TakeFunc...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.TakeFunc)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.TakeFunc)
[debug] Change NamesChange(com.local.CollectionFunction.TakeFunc,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(TakeFunc,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ticker,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.TakeFunc has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(TakeFunc,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ticker,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.TakeFunc)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.ClassesAndObject.Type_Aliasing.TypeAliasVsCaseClassHotel.Hotel...
[debug] Initial set of included nodes: Set(com.local.ClassesAndObject.Type_Aliasing.TypeAliasVsCaseClassHotel.Hotel)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.ClassesAndObject.Type_Aliasing.TypeAliasVsCaseClassHotel.Hotel)
[debug] Change NamesChange(com.local.ClassesAndObject.Type_Aliasing.TypeAliasVsCaseClassHotel.Hotel,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(avgCostPerNight,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(apply,[Default]), UsedName(notify,[Default]), UsedName(unapply,[Default]), UsedName(curried,[Default]), UsedName(productElement,[Default]), UsedName(copy$default$1,[Default]), UsedName(name,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$3,[Default]), UsedName(copy,[Default]), UsedName(wait,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(productElementNames,[Default]), UsedName(toString,[Default]), UsedName(tupled,[Default]), UsedName(!=,[Default]), UsedName(com;local;ClassesAndObject;Type_Aliasing;TypeAliasVsCaseClassHotel;Hotel;init;,[Default]), UsedName(productArity,[Default]), UsedName(<init>$default$3,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(clone,[Default]), UsedName(productElementName,[Default]), UsedName(apply$default$3,[Default]), UsedName(Hotel,[Default]), UsedName(address,[Default]), UsedName(notifyAll,[Default]), UsedName(productIterator,[Default]))) invalidates 1 classes due to The com.local.ClassesAndObject.Type_Aliasing.TypeAliasVsCaseClassHotel.Hotel has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(avgCostPerNight,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(apply,[Default]), UsedName(notify,[Default]), UsedName(unapply,[Default]), UsedName(curried,[Default]), UsedName(productElement,[Default]), UsedName(copy$default$1,[Default]), UsedName(name,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$3,[Default]), UsedName(copy,[Default]), UsedName(wait,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(productElementNames,[Default]), UsedName(toString,[Default]), UsedName(tupled,[Default]), UsedName(!=,[Default]), UsedName(com;local;ClassesAndObject;Type_Aliasing;TypeAliasVsCaseClassHotel;Hotel;init;,[Default]), UsedName(productArity,[Default]), UsedName(<init>$default$3,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(clone,[Default]), UsedName(productElementName,[Default]), UsedName(apply$default$3,[Default]), UsedName(Hotel,[Default]), UsedName(address,[Default]), UsedName(notifyAll,[Default]), UsedName(productIterator,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.ClassesAndObject.Type_Aliasing.TypeAliasVsCaseClassHotel.Hotel)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Financial_Instrument...
[debug] Initial set of included nodes: Set(com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Financial_Instrument)
[debug] Including com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Fixed_Income by com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Financial_Instrument
[debug] Including com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Equity by com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Financial_Instrument
[debug] Invalidated by transitive inheritance dependency: Set(com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Financial_Instrument, com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Fixed_Income, com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Equity)
[debug] The following modified names cause invalidation of com.local.ClassesAndObject.Covariance_TypeWithContraVariance.FinancialnstrumentType: Set(UsedName(Financial_Instrument,[Default]), UsedName(stat,[Default]))
[debug] The following modified names cause invalidation of com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Client_Covariance_Type: Set(UsedName(Financial_Instrument,[Default]))
[debug] The following modified names cause invalidation of com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Fixed_Income: Set(UsedName(asInstanceOf,[Default]), UsedName(cost,[Default]), UsedName(eq,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(Financial_Instrument,[Default]), UsedName(com;local;ClassesAndObject;Covariance_TypeWithContraVariance;Financial_Instrument;init;,[Default]))
[debug] The following modified names cause invalidation of com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Equity: Set(UsedName(asInstanceOf,[Default]), UsedName(cost,[Default]), UsedName(eq,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(Financial_Instrument,[Default]), UsedName(com;local;ClassesAndObject;Covariance_TypeWithContraVariance;Financial_Instrument;init;,[Default]))
[debug] The following modified names cause invalidation of com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Client_Covariance_Type: Set(UsedName(Financial_Instrument,[Default]))
[debug] The following modified names cause invalidation of com.local.ClassesAndObject.Covariance_TypeWithContraVariance.FinancialInstrumentTypeContraVariance: Set(UsedName(stat,[Default]))
[debug] The following modified names cause invalidation of com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Client_Covariance_Type: Set(UsedName(Financial_Instrument,[Default]))
[debug] Change NamesChange(com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Financial_Instrument,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(cost,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(Financial_Instrument,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(stat,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(clone,[Default]), UsedName(com;local;ClassesAndObject;Covariance_TypeWithContraVariance;Financial_Instrument;init;,[Default]), UsedName(notifyAll,[Default]))) invalidates 6 classes due to The com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Financial_Instrument has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(cost,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(Financial_Instrument,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(stat,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(clone,[Default]), UsedName(com;local;ClassesAndObject;Covariance_TypeWithContraVariance;Financial_Instrument;init;,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Financial_Instrument, com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Fixed_Income, com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Equity)
[debug] 	> 
[debug] 	> by member reference: Set(com.local.ClassesAndObject.Covariance_TypeWithContraVariance.FinancialnstrumentType, com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Client_Covariance_Type, com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Fixed_Income, com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Equity, com.local.ClassesAndObject.Covariance_TypeWithContraVariance.FinancialInstrumentTypeContraVariance)
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.ImmutableCollection.QueueCollection.QueueCollection...
[debug] Initial set of included nodes: Set(com.local.ImmutableCollection.QueueCollection.QueueCollection)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.ImmutableCollection.QueueCollection.QueueCollection)
[debug] Change NamesChange(com.local.ImmutableCollection.QueueCollection.QueueCollection,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(moreStocks,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(head,[Default]), UsedName(addStock,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(dequeue,[Default]), UsedName(wait,[Default]), UsedName(newStock,[Default]), UsedName(ne,[Default]), UsedName(emptyStock,[Default]), UsedName(societeGenerale,[Default]), UsedName(goldmanSacs,[Default]), UsedName(toString,[Default]), UsedName(QueueCollection,[Default]), UsedName(!=,[Default]), UsedName(stock,[Default]), UsedName(tail,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(stocks,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.ImmutableCollection.QueueCollection.QueueCollection has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(moreStocks,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(head,[Default]), UsedName(addStock,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(dequeue,[Default]), UsedName(wait,[Default]), UsedName(newStock,[Default]), UsedName(ne,[Default]), UsedName(emptyStock,[Default]), UsedName(societeGenerale,[Default]), UsedName(goldmanSacs,[Default]), UsedName(toString,[Default]), UsedName(QueueCollection,[Default]), UsedName(!=,[Default]), UsedName(stock,[Default]), UsedName(tail,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(stocks,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.ImmutableCollection.QueueCollection.QueueCollection)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.ScanFunc...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.ScanFunc)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.ScanFunc)
[debug] Change NamesChange(com.local.CollectionFunction.ScanFunc,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(ScanFunc,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(priceStock,[Default]), UsedName(executionStart,[Default]), UsedName(totalOfPreviousPair,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(totalOfPreviousPairWithVars,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.ScanFunc has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(ScanFunc,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(priceStock,[Default]), UsedName(executionStart,[Default]), UsedName(totalOfPreviousPair,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(totalOfPreviousPairWithVars,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.ScanFunc)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.ClassesAndObject.HotelSingletonClient...
[debug] Initial set of included nodes: Set(com.local.ClassesAndObject.HotelSingletonClient)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.ClassesAndObject.HotelSingletonClient)
[debug] Change NamesChange(com.local.ClassesAndObject.HotelSingletonClient,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(price,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(HotelSingletonClient,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(clone,[Default]), UsedName(price2,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.ClassesAndObject.HotelSingletonClient has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(price,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(HotelSingletonClient,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(clone,[Default]), UsedName(price2,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.ClassesAndObject.HotelSingletonClient)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.NonEmptyFunc...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.NonEmptyFunc)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.NonEmptyFunc)
[debug] Change NamesChange(com.local.CollectionFunction.NonEmptyFunc,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(isSeqHotelNonEmpty,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(emptyHotel,[Default]), UsedName(ne,[Default]), UsedName(seqHotel,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(NonEmptyFunc,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]), UsedName(isEmptyHotelNonEmpty,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.NonEmptyFunc has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(isSeqHotelNonEmpty,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(emptyHotel,[Default]), UsedName(ne,[Default]), UsedName(seqHotel,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(NonEmptyFunc,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]), UsedName(isEmptyHotelNonEmpty,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.NonEmptyFunc)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.review.Basic.ForControl.portfolio...
[debug] Initial set of included nodes: Set(com.review.Basic.ForControl.portfolio)
[debug] Invalidated by transitive inheritance dependency: Set(com.review.Basic.ForControl.portfolio)
[debug] Change NamesChange(com.review.Basic.ForControl.portfolio,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(apply,[Default]), UsedName(notify,[Default]), UsedName(unapply,[Default]), UsedName(curried,[Default]), UsedName(portfolio,[Default]), UsedName(productElement,[Default]), UsedName(copy$default$1,[Default]), UsedName(sizeDerivative,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(beta,[Default]), UsedName(copy$default$3,[Default]), UsedName(com;review;Basic;ForControl;portfolio;init;,[Default]), UsedName(copy,[Default]), UsedName(wait,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(productElementNames,[Default]), UsedName(toString,[Default]), UsedName(tupled,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(clone,[Default]), UsedName(productElementName,[Default]), UsedName(stocks,[Default]), UsedName(notifyAll,[Default]), UsedName(productIterator,[Default]))) invalidates 1 classes due to The com.review.Basic.ForControl.portfolio has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(apply,[Default]), UsedName(notify,[Default]), UsedName(unapply,[Default]), UsedName(curried,[Default]), UsedName(portfolio,[Default]), UsedName(productElement,[Default]), UsedName(copy$default$1,[Default]), UsedName(sizeDerivative,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(beta,[Default]), UsedName(copy$default$3,[Default]), UsedName(com;review;Basic;ForControl;portfolio;init;,[Default]), UsedName(copy,[Default]), UsedName(wait,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(productElementNames,[Default]), UsedName(toString,[Default]), UsedName(tupled,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(clone,[Default]), UsedName(productElementName,[Default]), UsedName(stocks,[Default]), UsedName(notifyAll,[Default]), UsedName(productIterator,[Default]).
[debug] 	> by transitive inheritance: Set(com.review.Basic.ForControl.portfolio)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.MinByFunc.Stock...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.MinByFunc.Stock)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.MinByFunc.Stock)
[debug] Change NamesChange(com.local.CollectionFunction.MinByFunc.Stock,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(Stock,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(apply,[Default]), UsedName(notify,[Default]), UsedName(unapply,[Default]), UsedName(curried,[Default]), UsedName(productElement,[Default]), UsedName(price,[Default]), UsedName(copy$default$1,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy,[Default]), UsedName(wait,[Default]), UsedName(ticker,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(productElementNames,[Default]), UsedName(com;local;CollectionFunction;MinByFunc;Stock;init;,[Default]), UsedName(toString,[Default]), UsedName(tupled,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(clone,[Default]), UsedName(productElementName,[Default]), UsedName(notifyAll,[Default]), UsedName(productIterator,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.MinByFunc.Stock has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(Stock,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(apply,[Default]), UsedName(notify,[Default]), UsedName(unapply,[Default]), UsedName(curried,[Default]), UsedName(productElement,[Default]), UsedName(price,[Default]), UsedName(copy$default$1,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy,[Default]), UsedName(wait,[Default]), UsedName(ticker,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(productElementNames,[Default]), UsedName(com;local;CollectionFunction;MinByFunc;Stock;init;,[Default]), UsedName(toString,[Default]), UsedName(tupled,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(clone,[Default]), UsedName(productElementName,[Default]), UsedName(notifyAll,[Default]), UsedName(productIterator,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.MinByFunc.Stock)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.TraitTraining.HotelFactory.Hotels.OtherHotels...
[debug] Initial set of included nodes: Set(com.local.TraitTraining.HotelFactory.Hotels.OtherHotels)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.TraitTraining.HotelFactory.Hotels.OtherHotels)
[debug] The following modified names cause invalidation of com.local.TraitTraining.HotelFactory.HotelFactory: Set(UsedName(com;local;TraitTraining;HotelFactory;Hotels;OtherHotels;init;,[Default]), UsedName(OtherHotels,[Default]))
[debug] Change NamesChange(com.local.TraitTraining.HotelFactory.Hotels.OtherHotels,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(name,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(com;local;TraitTraining;HotelFactory;Hotels;OtherHotels;init;,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(clone,[Default]), UsedName(OtherHotels,[Default]), UsedName(notifyAll,[Default]))) invalidates 2 classes due to The com.local.TraitTraining.HotelFactory.Hotels.OtherHotels has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(name,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(com;local;TraitTraining;HotelFactory;Hotels;OtherHotels;init;,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(clone,[Default]), UsedName(OtherHotels,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.TraitTraining.HotelFactory.Hotels.OtherHotels)
[debug] 	> 
[debug] 	> by member reference: Set(com.local.TraitTraining.HotelFactory.HotelFactory)
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.FlatMapFunc...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.FlatMapFunc)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.FlatMapFunc)
[debug] Change NamesChange(com.local.CollectionFunction.FlatMapFunc,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(internationalStocks,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(usStocks,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(FlatMapFunc,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(flattenStock,[Default]), UsedName(main,[Default]), UsedName(stocks,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.FlatMapFunc has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(internationalStocks,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(usStocks,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(FlatMapFunc,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(flattenStock,[Default]), UsedName(main,[Default]), UsedName(stocks,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.FlatMapFunc)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.MaxFunc...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.MaxFunc)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.MaxFunc)
[debug] Change NamesChange(com.local.CollectionFunction.MaxFunc,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(maxStockPrice,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(stockName,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(MaxFunc,[Default]), UsedName(maxStockName,[Default]), UsedName(wait,[Default]), UsedName(stockPrice,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.MaxFunc has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(maxStockPrice,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(stockName,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(MaxFunc,[Default]), UsedName(maxStockName,[Default]), UsedName(wait,[Default]), UsedName(stockPrice,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.MaxFunc)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.ClassesAndObject.Singleton.HotelPricingCalculatorSingleton...
[debug] Initial set of included nodes: Set(com.local.ClassesAndObject.Singleton.HotelPricingCalculatorSingleton)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.ClassesAndObject.Singleton.HotelPricingCalculatorSingleton)
[debug] The following modified names cause invalidation of com.local.ClassesAndObject.Singleton.ClientSingletonHotelCalculator: Set(UsedName(hashCode,[Default]), UsedName(calculate,[Default]), UsedName(HotelPricingCalculatorSingleton,[Default]))
[debug] Change NamesChange(com.local.ClassesAndObject.Singleton.HotelPricingCalculatorSingleton,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(calculate,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(HotelPricingCalculatorSingleton,[Default]), UsedName(clone,[Default]), UsedName(notifyAll,[Default]))) invalidates 2 classes due to The com.local.ClassesAndObject.Singleton.HotelPricingCalculatorSingleton has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(calculate,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(HotelPricingCalculatorSingleton,[Default]), UsedName(clone,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.ClassesAndObject.Singleton.HotelPricingCalculatorSingleton)
[debug] 	> 
[debug] 	> by member reference: Set(com.local.ClassesAndObject.Singleton.ClientSingletonHotelCalculator)
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.ClassesAndObject.Implicit.HotelImplictCaseClass.HotelImplicts...
[debug] Initial set of included nodes: Set(com.local.ClassesAndObject.Implicit.HotelImplictCaseClass.HotelImplicts)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.ClassesAndObject.Implicit.HotelImplictCaseClass.HotelImplicts)
[debug] Change NamesChange(com.local.ClassesAndObject.Implicit.HotelImplictCaseClass.HotelImplicts,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(AugmentedHotel,[Implicit]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(clone,[Default]), UsedName(HotelImplicts,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.ClassesAndObject.Implicit.HotelImplictCaseClass.HotelImplicts has the following implicit definitions changed:
[debug] 	UsedName(AugmentedHotel,[Implicit]).
[debug] 	> by transitive inheritance: Set(com.local.ClassesAndObject.Implicit.HotelImplictCaseClass.HotelImplicts)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.com.projects.financial.TestAlphaAdvantage...
[debug] Initial set of included nodes: Set(com.com.projects.financial.TestAlphaAdvantage)
[debug] Invalidated by transitive inheritance dependency: Set(com.com.projects.financial.TestAlphaAdvantage)
[debug] Change NamesChange(com.com.projects.financial.TestAlphaAdvantage,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(TestAlphaAdvantage,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(client,[Default]), UsedName(main,[Default]), UsedName(key,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.com.projects.financial.TestAlphaAdvantage has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(TestAlphaAdvantage,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(client,[Default]), UsedName(main,[Default]), UsedName(key,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.com.projects.financial.TestAlphaAdvantage)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.UnionFunc...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.UnionFunc)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.UnionFunc)
[debug] Change NamesChange(com.local.CollectionFunction.UnionFunc,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(dataFrame,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(dataFrame2,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(UnionFunc,[Default]), UsedName(hashCode,[Default]), UsedName(unionDFonDF2,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(unionDF2onDF,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.UnionFunc has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(dataFrame,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(dataFrame2,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(UnionFunc,[Default]), UsedName(hashCode,[Default]), UsedName(unionDFonDF2,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(unionDF2onDF,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.UnionFunc)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.TraitTraining.ExtMultiTraits.SecurityBasic...
[debug] Initial set of included nodes: Set(com.local.TraitTraining.ExtMultiTraits.SecurityBasic)
[debug] Including com.local.TraitTraining.ExtMultiTraits.Trade by com.local.TraitTraining.ExtMultiTraits.SecurityBasic
[debug] Invalidated by transitive inheritance dependency: Set(com.local.TraitTraining.ExtMultiTraits.SecurityBasic, com.local.TraitTraining.ExtMultiTraits.Trade)
[debug] The following modified names cause invalidation of com.local.TraitTraining.ExtMultiTraits.Trade: Set(UsedName(SecurityBasic,[Default]))
[debug] The following modified names cause invalidation of com.local.TraitTraining.ExtMultiTraits.Client: Set(UsedName(buy,[Default]), UsedName(sell,[Default]))
[debug] Change NamesChange(com.local.TraitTraining.ExtMultiTraits.SecurityBasic,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(buy,[Default]), UsedName(notify,[Default]), UsedName(sell,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(SecurityBasic,[Default]), UsedName(clone,[Default]), UsedName(hold,[Default]), UsedName(notifyAll,[Default]))) invalidates 3 classes due to The com.local.TraitTraining.ExtMultiTraits.SecurityBasic has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(buy,[Default]), UsedName(notify,[Default]), UsedName(sell,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(SecurityBasic,[Default]), UsedName(clone,[Default]), UsedName(hold,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.TraitTraining.ExtMultiTraits.SecurityBasic, com.local.TraitTraining.ExtMultiTraits.Trade)
[debug] 	> 
[debug] 	> by member reference: Set(com.local.TraitTraining.ExtMultiTraits.Trade, com.local.TraitTraining.ExtMultiTraits.Client)
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.FindFunc...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.FindFunc)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.FindFunc)
[debug] Change NamesChange(com.local.CollectionFunction.FindFunc,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(returnBond,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(FindFunc,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(returnCommodity,[Default]), UsedName(main,[Default]), UsedName(financialInstrument,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.FindFunc has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(returnBond,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(FindFunc,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(returnCommodity,[Default]), UsedName(main,[Default]), UsedName(financialInstrument,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.FindFunc)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.ImmutableCollection.ListCollection.MethodList...
[debug] Initial set of included nodes: Set(com.local.ImmutableCollection.ListCollection.MethodList)
[debug] Including com.local.ImmutableCollection.ListCollection.ListCollection by com.local.ImmutableCollection.ListCollection.MethodList
[debug] Invalidated by transitive inheritance dependency: Set(com.local.ImmutableCollection.ListCollection.MethodList, com.local.ImmutableCollection.ListCollection.ListCollection)
[debug] The following modified names cause invalidation of com.local.ImmutableCollection.ListCollection.ListCollection: Set(UsedName(frontAddList,[Default]), UsedName(queryList,[Default]), UsedName(firstAppendList,[Default]), UsedName(lastAppendList,[Default]), UsedName(MethodList,[Default]), UsedName(lastAddList,[Default]))
[debug] Change NamesChange(com.local.ImmutableCollection.ListCollection.MethodList,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(frontAddList,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(queryList,[Default]), UsedName(notify,[Default]), UsedName(firstAppendList,[Default]), UsedName(lastAppendList,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(MethodList,[Default]), UsedName(lastAddList,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(notifyAll,[Default]))) invalidates 2 classes due to The com.local.ImmutableCollection.ListCollection.MethodList has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(frontAddList,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(queryList,[Default]), UsedName(notify,[Default]), UsedName(firstAppendList,[Default]), UsedName(lastAppendList,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(MethodList,[Default]), UsedName(lastAddList,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.ImmutableCollection.ListCollection.MethodList, com.local.ImmutableCollection.ListCollection.ListCollection)
[debug] 	> 
[debug] 	> by member reference: Set(com.local.ImmutableCollection.ListCollection.ListCollection)
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.ImmutableCollection.MapCollection.MapCollection...
[debug] Initial set of included nodes: Set(com.local.ImmutableCollection.MapCollection.MapCollection)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.ImmutableCollection.MapCollection.MapCollection)
[debug] Change NamesChange(com.local.ImmutableCollection.MapCollection.MapCollection,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(stockAdd,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(updateStocks,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(socRemovedMap,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(stockWrongAdd,[Default]), UsedName(ne,[Default]), UsedName(socStock,[Default]), UsedName(emptyStock,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(MapCollection,[Default]), UsedName(goldmanStock,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(goldmanStockGS,[Default]), UsedName(main,[Default]), UsedName(stocks,[Default]), UsedName(mapPlusMap,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.ImmutableCollection.MapCollection.MapCollection has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(stockAdd,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(updateStocks,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(socRemovedMap,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(stockWrongAdd,[Default]), UsedName(ne,[Default]), UsedName(socStock,[Default]), UsedName(emptyStock,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(MapCollection,[Default]), UsedName(goldmanStock,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(goldmanStockGS,[Default]), UsedName(main,[Default]), UsedName(stocks,[Default]), UsedName(mapPlusMap,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.ImmutableCollection.MapCollection.MapCollection)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.ClassesAndObject.Case.CaseHotel.Hotel...
[debug] Initial set of included nodes: Set(com.local.ClassesAndObject.Case.CaseHotel.Hotel)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.ClassesAndObject.Case.CaseHotel.Hotel)
[debug] Change NamesChange(com.local.ClassesAndObject.Case.CaseHotel.Hotel,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(apply,[Default]), UsedName(notify,[Default]), UsedName(unapply,[Default]), UsedName(curried,[Default]), UsedName(productElement,[Default]), UsedName(copy$default$1,[Default]), UsedName(name,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$3,[Default]), UsedName(copy,[Default]), UsedName(wait,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(productElementNames,[Default]), UsedName(showDescription,[Default]), UsedName(costPerNight,[Default]), UsedName(toString,[Default]), UsedName(tupled,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(clone,[Default]), UsedName(productElementName,[Default]), UsedName(com;local;ClassesAndObject;Case;CaseHotel;Hotel;init;,[Default]), UsedName(Hotel,[Default]), UsedName(address,[Default]), UsedName(notifyAll,[Default]), UsedName(productIterator,[Default]))) invalidates 1 classes due to The com.local.ClassesAndObject.Case.CaseHotel.Hotel has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(apply,[Default]), UsedName(notify,[Default]), UsedName(unapply,[Default]), UsedName(curried,[Default]), UsedName(productElement,[Default]), UsedName(copy$default$1,[Default]), UsedName(name,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$3,[Default]), UsedName(copy,[Default]), UsedName(wait,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(productElementNames,[Default]), UsedName(showDescription,[Default]), UsedName(costPerNight,[Default]), UsedName(toString,[Default]), UsedName(tupled,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(clone,[Default]), UsedName(productElementName,[Default]), UsedName(com;local;ClassesAndObject;Case;CaseHotel;Hotel;init;,[Default]), UsedName(Hotel,[Default]), UsedName(address,[Default]), UsedName(notifyAll,[Default]), UsedName(productIterator,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.ClassesAndObject.Case.CaseHotel.Hotel)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.ClassesAndObject.HotelPricingCalculatorSingleton...
[debug] Initial set of included nodes: Set(com.local.ClassesAndObject.HotelPricingCalculatorSingleton)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.ClassesAndObject.HotelPricingCalculatorSingleton)
[debug] Change NamesChange(com.local.ClassesAndObject.HotelPricingCalculatorSingleton,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(calculate,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(HotelPricingCalculatorSingleton,[Default]), UsedName(clone,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.ClassesAndObject.HotelPricingCalculatorSingleton has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(calculate,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(HotelPricingCalculatorSingleton,[Default]), UsedName(clone,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.ClassesAndObject.HotelPricingCalculatorSingleton)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.PartitionFunc...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.PartitionFunc)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.PartitionFunc)
[debug] Change NamesChange(com.local.CollectionFunction.PartitionFunc,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(hotel,[Default]), UsedName(PartitionFunc,[Default]), UsedName(wait,[Default]), UsedName(partionHotelAndPrice,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.PartitionFunc has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(hotel,[Default]), UsedName(PartitionFunc,[Default]), UsedName(wait,[Default]), UsedName(partionHotelAndPrice,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.PartitionFunc)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.TraitTraining.HotelFactory.Hotels.PaperFactoryHotel...
[debug] Initial set of included nodes: Set(com.local.TraitTraining.HotelFactory.Hotels.PaperFactoryHotel)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.TraitTraining.HotelFactory.Hotels.PaperFactoryHotel)
[debug] The following modified names cause invalidation of com.local.TraitTraining.HotelFactory.HotelFactory: Set(UsedName(PaperFactoryHotel,[Default]), UsedName(com;local;TraitTraining;HotelFactory;Hotels;PaperFactoryHotel;init;,[Default]))
[debug] Change NamesChange(com.local.TraitTraining.HotelFactory.Hotels.PaperFactoryHotel,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(name,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(clone,[Default]), UsedName(PaperFactoryHotel,[Default]), UsedName(notifyAll,[Default]), UsedName(com;local;TraitTraining;HotelFactory;Hotels;PaperFactoryHotel;init;,[Default]))) invalidates 2 classes due to The com.local.TraitTraining.HotelFactory.Hotels.PaperFactoryHotel has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(name,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(clone,[Default]), UsedName(PaperFactoryHotel,[Default]), UsedName(notifyAll,[Default]), UsedName(com;local;TraitTraining;HotelFactory;Hotels;PaperFactoryHotel;init;,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.TraitTraining.HotelFactory.Hotels.PaperFactoryHotel)
[debug] 	> 
[debug] 	> by member reference: Set(com.local.TraitTraining.HotelFactory.HotelFactory)
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.ClassesAndObject.Abstract.CaseHotelExtendedWithAbstact...
[debug] Initial set of included nodes: Set(com.local.ClassesAndObject.Abstract.CaseHotelExtendedWithAbstact)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.ClassesAndObject.Abstract.CaseHotelExtendedWithAbstact)
[debug] The following modified names cause invalidation of com.local.ClassesAndObject.Abstract.ClientExtendOfHotelAbstract: Set(UsedName(CaseHotelExtendedWithAbstact,[Default]), UsedName(stats,[Default]), UsedName(com;local;ClassesAndObject;Abstract;CaseHotelExtendedWithAbstact;init;,[Default]))
[debug] Change NamesChange(com.local.ClassesAndObject.Abstract.CaseHotelExtendedWithAbstact,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(cost,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(location,[Default]), UsedName(productElement,[Default]), UsedName(copy$default$1,[Default]), UsedName(name,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$3,[Default]), UsedName(copy,[Default]), UsedName(wait,[Default]), UsedName(CaseHotelExtendedWithAbstact,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(productElementNames,[Default]), UsedName(stats,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(com;local;ClassesAndObject;Abstract;CaseHotelExtendedWithAbstact;init;,[Default]), UsedName(clone,[Default]), UsedName(productElementName,[Default]), UsedName(notifyAll,[Default]), UsedName(productIterator,[Default]))) invalidates 2 classes due to The com.local.ClassesAndObject.Abstract.CaseHotelExtendedWithAbstact has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(cost,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(location,[Default]), UsedName(productElement,[Default]), UsedName(copy$default$1,[Default]), UsedName(name,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$3,[Default]), UsedName(copy,[Default]), UsedName(wait,[Default]), UsedName(CaseHotelExtendedWithAbstact,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(productElementNames,[Default]), UsedName(stats,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(com;local;ClassesAndObject;Abstract;CaseHotelExtendedWithAbstact;init;,[Default]), UsedName(clone,[Default]), UsedName(productElementName,[Default]), UsedName(notifyAll,[Default]), UsedName(productIterator,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.ClassesAndObject.Abstract.CaseHotelExtendedWithAbstact)
[debug] 	> 
[debug] 	> by member reference: Set(com.local.ClassesAndObject.Abstract.ClientExtendOfHotelAbstract)
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.ClassesAndObject.Typed_Class.Airbnb...
[debug] Initial set of included nodes: Set(com.local.ClassesAndObject.Typed_Class.Airbnb)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.ClassesAndObject.Typed_Class.Airbnb)
[debug] The following modified names cause invalidation of com.local.ClassesAndObject.Typed_Class.TypedClient: Set(UsedName(Airbnb,[Default]), UsedName(com;local;ClassesAndObject;Typed_Class;Airbnb;init;,[Default]))
[debug] Change NamesChange(com.local.ClassesAndObject.Typed_Class.Airbnb,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(cost,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(location,[Default]), UsedName(productElement,[Default]), UsedName(Airbnb,[Default]), UsedName(copy$default$1,[Default]), UsedName(name,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$3,[Default]), UsedName(copy,[Default]), UsedName(wait,[Default]), UsedName(com;local;ClassesAndObject;Typed_Class;Airbnb;init;,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(productElementNames,[Default]), UsedName(stats,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(clone,[Default]), UsedName(productElementName,[Default]), UsedName(notifyAll,[Default]), UsedName(productIterator,[Default]))) invalidates 2 classes due to The com.local.ClassesAndObject.Typed_Class.Airbnb has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(cost,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(location,[Default]), UsedName(productElement,[Default]), UsedName(Airbnb,[Default]), UsedName(copy$default$1,[Default]), UsedName(name,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$3,[Default]), UsedName(copy,[Default]), UsedName(wait,[Default]), UsedName(com;local;ClassesAndObject;Typed_Class;Airbnb;init;,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(productElementNames,[Default]), UsedName(stats,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(clone,[Default]), UsedName(productElementName,[Default]), UsedName(notifyAll,[Default]), UsedName(productIterator,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.ClassesAndObject.Typed_Class.Airbnb)
[debug] 	> 
[debug] 	> by member reference: Set(com.local.ClassesAndObject.Typed_Class.TypedClient)
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.GroupByFunc...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.GroupByFunc)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.GroupByFunc)
[debug] Change NamesChange(com.local.CollectionFunction.GroupByFunc,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(Stock,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(GroupByFunc,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(groupBySeq,[Default]), UsedName(bxStock,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(wfcStock,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(mapStock,[Default]), UsedName(wait,[Default]), UsedName(jpmStock,[Default]), UsedName(seqStocks,[Default]), UsedName(cStock,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(stock,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]), UsedName(bacStock,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.GroupByFunc has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(Stock,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(GroupByFunc,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(groupBySeq,[Default]), UsedName(bxStock,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(wfcStock,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(mapStock,[Default]), UsedName(wait,[Default]), UsedName(jpmStock,[Default]), UsedName(seqStocks,[Default]), UsedName(cStock,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(stock,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]), UsedName(bacStock,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.GroupByFunc)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.CollectFunc...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.CollectFunc)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.CollectFunc)
[debug] Change NamesChange(com.local.CollectionFunction.CollectFunc,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(CollectFunc,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(stockWithPrice,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(tickers,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(prices,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.CollectFunc has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(CollectFunc,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(stockWithPrice,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(tickers,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(prices,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.CollectFunc)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.ClassesAndObject.Singleton.ClientSingletonHotelCalculator...
[debug] Initial set of included nodes: Set(com.local.ClassesAndObject.Singleton.ClientSingletonHotelCalculator)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.ClassesAndObject.Singleton.ClientSingletonHotelCalculator)
[debug] Change NamesChange(com.local.ClassesAndObject.Singleton.ClientSingletonHotelCalculator,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(price,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(ClientSingletonHotelCalculator,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(price2,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.ClassesAndObject.Singleton.ClientSingletonHotelCalculator has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(price,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(ClientSingletonHotelCalculator,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(price2,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.ClassesAndObject.Singleton.ClientSingletonHotelCalculator)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.TailFunc...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.TailFunc)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.TailFunc)
[debug] Change NamesChange(com.local.CollectionFunction.TailFunc,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(tailTicker,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(TailFunc,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ticker,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.TailFunc has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(tailTicker,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(TailFunc,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ticker,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.TailFunc)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.TraitTraining.ExtMultiTraits.Client...
[debug] Initial set of included nodes: Set(com.local.TraitTraining.ExtMultiTraits.Client)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.TraitTraining.ExtMultiTraits.Client)
[debug] Change NamesChange(com.local.TraitTraining.ExtMultiTraits.Client,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(bondConversion,[Default]), UsedName(wait,[Default]), UsedName(tradeExe,[Default]), UsedName(ne,[Default]), UsedName(Client,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(BlackstoneCorporateBond,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(BlackstoneEquity,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.TraitTraining.ExtMultiTraits.Client has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(bondConversion,[Default]), UsedName(wait,[Default]), UsedName(tradeExe,[Default]), UsedName(ne,[Default]), UsedName(Client,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(BlackstoneCorporateBond,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(BlackstoneEquity,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.TraitTraining.ExtMultiTraits.Client)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.TraitTraining.TypeParameters.Trade...
[debug] Initial set of included nodes: Set(com.local.TraitTraining.TypeParameters.Trade)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.TraitTraining.TypeParameters.Trade)
[debug] The following modified names cause invalidation of com.local.TraitTraining.TypeParameters.Client: Set(UsedName(buy,[Default]), UsedName(com;local;TraitTraining;TypeParameters;Trade;init;,[Default]), UsedName(sell,[Default]), UsedName(Trade,[Default]))
[debug] Change NamesChange(com.local.TraitTraining.TypeParameters.Trade,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(buy,[Default]), UsedName(notify,[Default]), UsedName(com;local;TraitTraining;TypeParameters;Trade;init;,[Default]), UsedName(sell,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(Trade,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(clone,[Default]), UsedName(hold,[Default]), UsedName(notifyAll,[Default]))) invalidates 2 classes due to The com.local.TraitTraining.TypeParameters.Trade has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(buy,[Default]), UsedName(notify,[Default]), UsedName(com;local;TraitTraining;TypeParameters;Trade;init;,[Default]), UsedName(sell,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(Trade,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(clone,[Default]), UsedName(hold,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.TraitTraining.TypeParameters.Trade)
[debug] 	> 
[debug] 	> by member reference: Set(com.local.TraitTraining.TypeParameters.Client)
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.TraitTraining.TypeParameters.SecurtiesFunctions...
[debug] Initial set of included nodes: Set(com.local.TraitTraining.TypeParameters.SecurtiesFunctions)
[debug] Including com.local.TraitTraining.TypeParameters.Trade by com.local.TraitTraining.TypeParameters.SecurtiesFunctions
[debug] Invalidated by transitive inheritance dependency: Set(com.local.TraitTraining.TypeParameters.SecurtiesFunctions, com.local.TraitTraining.TypeParameters.Trade)
[debug] The following modified names cause invalidation of com.local.TraitTraining.TypeParameters.Trade: Set(UsedName(==,[Default]), UsedName(SecurtiesFunctions,[Default]))
[debug] The following modified names cause invalidation of com.local.TraitTraining.TypeParameters.Client: Set(UsedName(buy,[Default]), UsedName(sell,[Default]))
[debug] Change NamesChange(com.local.TraitTraining.TypeParameters.SecurtiesFunctions,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(buy,[Default]), UsedName(notify,[Default]), UsedName(sell,[Default]), UsedName(SecurtiesFunctions,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(clone,[Default]), UsedName(hold,[Default]), UsedName(notifyAll,[Default]))) invalidates 3 classes due to The com.local.TraitTraining.TypeParameters.SecurtiesFunctions has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(buy,[Default]), UsedName(notify,[Default]), UsedName(sell,[Default]), UsedName(SecurtiesFunctions,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(clone,[Default]), UsedName(hold,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.TraitTraining.TypeParameters.SecurtiesFunctions, com.local.TraitTraining.TypeParameters.Trade)
[debug] 	> 
[debug] 	> by member reference: Set(com.local.TraitTraining.TypeParameters.Trade, com.local.TraitTraining.TypeParameters.Client)
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.IntersectFunc...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.IntersectFunc)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.IntersectFunc)
[debug] Change NamesChange(com.local.CollectionFunction.IntersectFunc,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(americanStock,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(foreignStock,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(IntersectFunc,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(commonStock,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.IntersectFunc has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(americanStock,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(foreignStock,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(IntersectFunc,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(commonStock,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.IntersectFunc)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.DiffFunc...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.DiffFunc)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.DiffFunc)
[debug] Change NamesChange(com.local.CollectionFunction.DiffFunc,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(dif2SubtractionSign,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(difbetweenSets2,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(DiffFunc,[Default]), UsedName(wait,[Default]), UsedName(hotels,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(moreHotels,[Default]), UsedName(difBetweenSets,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.DiffFunc has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(dif2SubtractionSign,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(difbetweenSets2,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(DiffFunc,[Default]), UsedName(wait,[Default]), UsedName(hotels,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(moreHotels,[Default]), UsedName(difBetweenSets,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.DiffFunc)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.TraitTraining.HotelFactory.Hotels.FeatherFactoryHotel...
[debug] Initial set of included nodes: Set(com.local.TraitTraining.HotelFactory.Hotels.FeatherFactoryHotel)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.TraitTraining.HotelFactory.Hotels.FeatherFactoryHotel)
[debug] The following modified names cause invalidation of com.local.TraitTraining.HotelFactory.HotelFactory: Set(UsedName(FeatherFactoryHotel,[Default]), UsedName(com;local;TraitTraining;HotelFactory;Hotels;FeatherFactoryHotel;init;,[Default]))
[debug] Change NamesChange(com.local.TraitTraining.HotelFactory.Hotels.FeatherFactoryHotel,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(FeatherFactoryHotel,[Default]), UsedName(name,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(com;local;TraitTraining;HotelFactory;Hotels;FeatherFactoryHotel;init;,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(clone,[Default]), UsedName(notifyAll,[Default]))) invalidates 2 classes due to The com.local.TraitTraining.HotelFactory.Hotels.FeatherFactoryHotel has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(FeatherFactoryHotel,[Default]), UsedName(name,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(com;local;TraitTraining;HotelFactory;Hotels;FeatherFactoryHotel;init;,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(clone,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.TraitTraining.HotelFactory.Hotels.FeatherFactoryHotel)
[debug] 	> 
[debug] 	> by member reference: Set(com.local.TraitTraining.HotelFactory.HotelFactory)
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Client_Covariance_Type...
[debug] Initial set of included nodes: Set(com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Client_Covariance_Type)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Client_Covariance_Type)
[debug] Change NamesChange(com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Client_Covariance_Type,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(equityType,[Default]), UsedName(finType,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(bond2,[Default]), UsedName(bond,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(equity,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(Client_Covariance_Type,[Default]), UsedName(seqFinancialInstruments,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Client_Covariance_Type has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(equityType,[Default]), UsedName(finType,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(bond2,[Default]), UsedName(bond,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(equity,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(Client_Covariance_Type,[Default]), UsedName(seqFinancialInstruments,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Client_Covariance_Type)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.review.Basic.IfElseControl.Stock...
[debug] Initial set of included nodes: Set(com.review.Basic.IfElseControl.Stock)
[debug] Invalidated by transitive inheritance dependency: Set(com.review.Basic.IfElseControl.Stock)
[debug] Change NamesChange(com.review.Basic.IfElseControl.Stock,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(Stock,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(apply,[Default]), UsedName(notify,[Default]), UsedName(unapply,[Default]), UsedName(curried,[Default]), UsedName(productElement,[Default]), UsedName(price,[Default]), UsedName(copy$default$1,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy,[Default]), UsedName(wait,[Default]), UsedName(ticker,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(productElementNames,[Default]), UsedName(com;review;Basic;IfElseControl;Stock;init;,[Default]), UsedName(toString,[Default]), UsedName(tupled,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(clone,[Default]), UsedName(productElementName,[Default]), UsedName(notifyAll,[Default]), UsedName(productIterator,[Default]))) invalidates 1 classes due to The com.review.Basic.IfElseControl.Stock has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(Stock,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(apply,[Default]), UsedName(notify,[Default]), UsedName(unapply,[Default]), UsedName(curried,[Default]), UsedName(productElement,[Default]), UsedName(price,[Default]), UsedName(copy$default$1,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy,[Default]), UsedName(wait,[Default]), UsedName(ticker,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(productElementNames,[Default]), UsedName(com;review;Basic;IfElseControl;Stock;init;,[Default]), UsedName(toString,[Default]), UsedName(tupled,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(clone,[Default]), UsedName(productElementName,[Default]), UsedName(notifyAll,[Default]), UsedName(productIterator,[Default]).
[debug] 	> by transitive inheritance: Set(com.review.Basic.IfElseControl.Stock)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.FilterNotFilterFunc...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.FilterNotFilterFunc)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.FilterNotFilterFunc)
[debug] Change NamesChange(com.local.CollectionFunction.FilterNotFilterFunc,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(FilterNotFilterFunc,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(filterCiti,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(notFilterCiti,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(stocks,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.FilterNotFilterFunc has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(FilterNotFilterFunc,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(filterCiti,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(notFilterCiti,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(stocks,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.FilterNotFilterFunc)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.SortByFunc...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.SortByFunc)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.SortByFunc)
[debug] Change NamesChange(com.local.CollectionFunction.SortByFunc,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(SortByFunc,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(hotels,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(sortedHotelByName,[Default]), UsedName(main,[Default]), UsedName(Hotel,[Default]), UsedName(notifyAll,[Default]), UsedName(sortedHotelByPrice,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.SortByFunc has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(SortByFunc,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(hotels,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(sortedHotelByName,[Default]), UsedName(main,[Default]), UsedName(Hotel,[Default]), UsedName(notifyAll,[Default]), UsedName(sortedHotelByPrice,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.SortByFunc)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.HotelAttributes.AugmentedHotel...
[debug] Initial set of included nodes: Set(com.local.HotelAttributes.AugmentedHotel)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.HotelAttributes.AugmentedHotel)
[debug] Change NamesChange(com.local.HotelAttributes.AugmentedHotel,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(uuid,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(com;local;HotelAttributes;AugmentedHotel;init;,[Default]), UsedName(ne,[Default]), UsedName(AugmentedHotel,[Implicit]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(clone,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.HotelAttributes.AugmentedHotel has the following implicit definitions changed:
[debug] 	UsedName(AugmentedHotel,[Implicit]).
[debug] 	> by transitive inheritance: Set(com.local.HotelAttributes.AugmentedHotel)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.TraitTraining.ExTrait.Equity...
[debug] Initial set of included nodes: Set(com.local.TraitTraining.ExTrait.Equity)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.TraitTraining.ExTrait.Equity)
[debug] The following modified names cause invalidation of com.local.TraitTraining.ExTrait.Client: Set(UsedName(Equity,[Default]), UsedName(buy,[Default]), UsedName(price,[Default]), UsedName(com;local;TraitTraining;ExTrait;Equity;init;,[Default]))
[debug] Change NamesChange(com.local.TraitTraining.ExTrait.Equity,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(hashCode,[Default]), UsedName(Equity,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(buy,[Default]), UsedName(notify,[Default]), UsedName(sell,[Default]), UsedName(productElement,[Default]), UsedName(price,[Default]), UsedName(copy$default$1,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy,[Default]), UsedName(wait,[Default]), UsedName(ticker,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(productElementNames,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(clone,[Default]), UsedName(hold,[Default]), UsedName(com;local;TraitTraining;ExTrait;Equity;init;,[Default]), UsedName(productElementName,[Default]), UsedName(notifyAll,[Default]), UsedName(productIterator,[Default]))) invalidates 2 classes due to The com.local.TraitTraining.ExTrait.Equity has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(hashCode,[Default]), UsedName(Equity,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(buy,[Default]), UsedName(notify,[Default]), UsedName(sell,[Default]), UsedName(productElement,[Default]), UsedName(price,[Default]), UsedName(copy$default$1,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy,[Default]), UsedName(wait,[Default]), UsedName(ticker,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(productElementNames,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(clone,[Default]), UsedName(hold,[Default]), UsedName(com;local;TraitTraining;ExTrait;Equity;init;,[Default]), UsedName(productElementName,[Default]), UsedName(notifyAll,[Default]), UsedName(productIterator,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.TraitTraining.ExTrait.Equity)
[debug] 	> 
[debug] 	> by member reference: Set(com.local.TraitTraining.ExTrait.Client)
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.TraitTraining.HotelFactory.HotelFactory...
[debug] Initial set of included nodes: Set(com.local.TraitTraining.HotelFactory.HotelFactory)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.TraitTraining.HotelFactory.HotelFactory)
[debug] The following modified names cause invalidation of com.local.TraitTraining.HotelFactory.Client: Set(UsedName(hotelSelection,[Default]), UsedName(HotelFactory,[Default]))
[debug] Change NamesChange(com.local.TraitTraining.HotelFactory.HotelFactory,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(hotelSelection,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(HotelFactory,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(clone,[Default]), UsedName(notifyAll,[Default]))) invalidates 2 classes due to The com.local.TraitTraining.HotelFactory.HotelFactory has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(hotelSelection,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(HotelFactory,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(clone,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.TraitTraining.HotelFactory.HotelFactory)
[debug] 	> 
[debug] 	> by member reference: Set(com.local.TraitTraining.HotelFactory.Client)
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.ImmutableCollection.SetCollection.SetCollection...
[debug] Initial set of included nodes: Set(com.local.ImmutableCollection.SetCollection.SetCollection)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.ImmutableCollection.SetCollection.SetCollection)
[debug] Change NamesChange(com.local.ImmutableCollection.SetCollection.SetCollection,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(flatWhite,[Default]), UsedName(delayedInit,[Default]), UsedName(ifAmericanoExist,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(coffeeSet2,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(addingCoffee,[Default]), UsedName(notify,[Default]), UsedName(intersectionSet,[Default]), UsedName(executionStart,[Default]), UsedName(diff,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(mochaccino,[Default]), UsedName(differenceBetweenSet,[Default]), UsedName(toString,[Default]), UsedName(SetCollection,[Default]), UsedName(!=,[Default]), UsedName(coffeeSet,[Default]), UsedName(removingEspresso,[Default]), UsedName(addingCoffeeSets,[Default]), UsedName(mochaccino2,[Default]), UsedName($init$,[Default]), UsedName(emptySet,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.ImmutableCollection.SetCollection.SetCollection has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(flatWhite,[Default]), UsedName(delayedInit,[Default]), UsedName(ifAmericanoExist,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(coffeeSet2,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(addingCoffee,[Default]), UsedName(notify,[Default]), UsedName(intersectionSet,[Default]), UsedName(executionStart,[Default]), UsedName(diff,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(mochaccino,[Default]), UsedName(differenceBetweenSet,[Default]), UsedName(toString,[Default]), UsedName(SetCollection,[Default]), UsedName(!=,[Default]), UsedName(coffeeSet,[Default]), UsedName(removingEspresso,[Default]), UsedName(addingCoffeeSets,[Default]), UsedName(mochaccino2,[Default]), UsedName($init$,[Default]), UsedName(emptySet,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.ImmutableCollection.SetCollection.SetCollection)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.MinByFunc...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.MinByFunc)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.MinByFunc)
[debug] Change NamesChange(com.local.CollectionFunction.MinByFunc,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(MinByFunc,[Default]), UsedName(Stock,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(stockPriceVF,[Default]), UsedName(notify,[Default]), UsedName(findMinStockPrice,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(stockSeq,[Default]), UsedName(main,[Default]), UsedName(findMinStockPriceWithVF,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.MinByFunc has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(MinByFunc,[Default]), UsedName(Stock,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(stockPriceVF,[Default]), UsedName(notify,[Default]), UsedName(findMinStockPrice,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(stockSeq,[Default]), UsedName(main,[Default]), UsedName(findMinStockPriceWithVF,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.MinByFunc)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.IsEmptyFunc...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.IsEmptyFunc)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.IsEmptyFunc)
[debug] Change NamesChange(com.local.CollectionFunction.IsEmptyFunc,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(movies,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(IsEmptyFunc,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(isEmptyMovies,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(moviesList,[Default]), UsedName(sizeOfMovies,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.IsEmptyFunc has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(movies,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(IsEmptyFunc,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(isEmptyMovies,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(moviesList,[Default]), UsedName(sizeOfMovies,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.IsEmptyFunc)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.ClassesAndObject.Abstract.ClientExtendOfHotelAbstract...
[debug] Initial set of included nodes: Set(com.local.ClassesAndObject.Abstract.ClientExtendOfHotelAbstract)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.ClassesAndObject.Abstract.ClientExtendOfHotelAbstract)
[debug] Change NamesChange(com.local.ClassesAndObject.Abstract.ClientExtendOfHotelAbstract,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(hotel2,[Default]), UsedName(hotel,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(ClientExtendOfHotelAbstract,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.ClassesAndObject.Abstract.ClientExtendOfHotelAbstract has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(hotel2,[Default]), UsedName(hotel,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(ClientExtendOfHotelAbstract,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.ClassesAndObject.Abstract.ClientExtendOfHotelAbstract)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.ClassesAndObject.Typed_Class.Hotel...
[debug] Initial set of included nodes: Set(com.local.ClassesAndObject.Typed_Class.Hotel)
[debug] Including com.local.ClassesAndObject.Typed_Class.Motel by com.local.ClassesAndObject.Typed_Class.Hotel
[debug] Including com.local.ClassesAndObject.Typed_Class.Airbnb by com.local.ClassesAndObject.Typed_Class.Hotel
[debug] Invalidated by transitive inheritance dependency: Set(com.local.ClassesAndObject.Typed_Class.Motel, com.local.ClassesAndObject.Typed_Class.Hotel, com.local.ClassesAndObject.Typed_Class.Airbnb)
[debug] The following modified names cause invalidation of com.local.ClassesAndObject.Typed_Class.TypedClient: Set(UsedName(Hotel,[Default]))
[debug] The following modified names cause invalidation of com.local.ClassesAndObject.Typed_Class.TypedClient: Set(UsedName(Hotel,[Default]))
[debug] The following modified names cause invalidation of com.local.ClassesAndObject.Typed_Class.Motel: Set(UsedName(com;local;ClassesAndObject;Typed_Class;Hotel;init;,[Default]), UsedName(Hotel,[Default]))
[debug] The following modified names cause invalidation of com.local.ClassesAndObject.Typed_Class.TypeHotels: Set(UsedName(stats,[Default]), UsedName(Hotel,[Default]))
[debug] The following modified names cause invalidation of com.local.ClassesAndObject.Typed_Class.Airbnb: Set(UsedName(asInstanceOf,[Default]), UsedName(eq,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(com;local;ClassesAndObject;Typed_Class;Hotel;init;,[Default]), UsedName(Hotel,[Default]))
[debug] The following modified names cause invalidation of com.local.ClassesAndObject.Typed_Class.TypedClient: Set(UsedName(Hotel,[Default]))
[debug] Change NamesChange(com.local.ClassesAndObject.Typed_Class.Hotel,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(com;local;ClassesAndObject;Typed_Class;Hotel;init;,[Default]), UsedName(notify,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(stats,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(clone,[Default]), UsedName(Hotel,[Default]), UsedName(notifyAll,[Default]))) invalidates 5 classes due to The com.local.ClassesAndObject.Typed_Class.Hotel has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(com;local;ClassesAndObject;Typed_Class;Hotel;init;,[Default]), UsedName(notify,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(stats,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(clone,[Default]), UsedName(Hotel,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.ClassesAndObject.Typed_Class.Motel, com.local.ClassesAndObject.Typed_Class.Hotel, com.local.ClassesAndObject.Typed_Class.Airbnb)
[debug] 	> 
[debug] 	> by member reference: Set(com.local.ClassesAndObject.Typed_Class.TypedClient, com.local.ClassesAndObject.Typed_Class.Motel, com.local.ClassesAndObject.Typed_Class.TypeHotels, com.local.ClassesAndObject.Typed_Class.Airbnb)
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.ClassesAndObject.Implicit.HotelImplictCaseClass...
[debug] Initial set of included nodes: Set(com.local.ClassesAndObject.Implicit.HotelImplictCaseClass)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.ClassesAndObject.Implicit.HotelImplictCaseClass)
[debug] Change NamesChange(com.local.ClassesAndObject.Implicit.HotelImplictCaseClass,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(HotelImplictCaseClass,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(hotel,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(HotelImplicts,[Default]), UsedName(main,[Default]), UsedName(Hotel,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.ClassesAndObject.Implicit.HotelImplictCaseClass has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(HotelImplictCaseClass,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(hotel,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(HotelImplicts,[Default]), UsedName(main,[Default]), UsedName(Hotel,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.ClassesAndObject.Implicit.HotelImplictCaseClass)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.TraitTraining.ExtMultiTraits.Trade...
[debug] Initial set of included nodes: Set(com.local.TraitTraining.ExtMultiTraits.Trade)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.TraitTraining.ExtMultiTraits.Trade)
[debug] The following modified names cause invalidation of com.local.TraitTraining.ExtMultiTraits.Client: Set(UsedName(buy,[Default]), UsedName(sell,[Default]), UsedName(com;local;TraitTraining;ExtMultiTraits;Trade;init;,[Default]), UsedName(Trade,[Default]), UsedName(convertSecurity,[Default]))
[debug] Change NamesChange(com.local.TraitTraining.ExtMultiTraits.Trade,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(buy,[Default]), UsedName(notify,[Default]), UsedName(sell,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(com;local;TraitTraining;ExtMultiTraits;Trade;init;,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(Trade,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(clone,[Default]), UsedName(hold,[Default]), UsedName(convertSecurity,[Default]), UsedName(notifyAll,[Default]))) invalidates 2 classes due to The com.local.TraitTraining.ExtMultiTraits.Trade has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(buy,[Default]), UsedName(notify,[Default]), UsedName(sell,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(com;local;TraitTraining;ExtMultiTraits;Trade;init;,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(Trade,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(clone,[Default]), UsedName(hold,[Default]), UsedName(convertSecurity,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.TraitTraining.ExtMultiTraits.Trade)
[debug] 	> 
[debug] 	> by member reference: Set(com.local.TraitTraining.ExtMultiTraits.Client)
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.ClassesAndObject.Covariance_TypeWithContraVariance.FinancialnstrumentType...
[debug] Initial set of included nodes: Set(com.local.ClassesAndObject.Covariance_TypeWithContraVariance.FinancialnstrumentType)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.ClassesAndObject.Covariance_TypeWithContraVariance.FinancialnstrumentType)
[debug] The following modified names cause invalidation of com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Client_Covariance_Type: Set(UsedName(printStats,[Default]), UsedName(FinancialnstrumentType,[Default]), UsedName(com;local;ClassesAndObject;Covariance_TypeWithContraVariance;FinancialnstrumentType;init;,[Default]))
[debug] Change NamesChange(com.local.ClassesAndObject.Covariance_TypeWithContraVariance.FinancialnstrumentType,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(printStats,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(FinancialnstrumentType,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(clone,[Default]), UsedName(com;local;ClassesAndObject;Covariance_TypeWithContraVariance;FinancialnstrumentType;init;,[Default]), UsedName(notifyAll,[Default]))) invalidates 2 classes due to The com.local.ClassesAndObject.Covariance_TypeWithContraVariance.FinancialnstrumentType has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(printStats,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(FinancialnstrumentType,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(clone,[Default]), UsedName(com;local;ClassesAndObject;Covariance_TypeWithContraVariance;FinancialnstrumentType;init;,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.ClassesAndObject.Covariance_TypeWithContraVariance.FinancialnstrumentType)
[debug] 	> 
[debug] 	> by member reference: Set(com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Client_Covariance_Type)
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.TraitTraining.TypeParameters.Client...
[debug] Initial set of included nodes: Set(com.local.TraitTraining.TypeParameters.Client)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.TraitTraining.TypeParameters.Client)
[debug] Change NamesChange(com.local.TraitTraining.TypeParameters.Client,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(yield30yr,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(bx,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(trade,[Default]), UsedName(Client,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.TraitTraining.TypeParameters.Client has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(yield30yr,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(bx,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(trade,[Default]), UsedName(Client,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.TraitTraining.TypeParameters.Client)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.ClassesAndObject.Implicit.HotelImplictCaseClass.Hotel...
[debug] Initial set of included nodes: Set(com.local.ClassesAndObject.Implicit.HotelImplictCaseClass.Hotel)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.ClassesAndObject.Implicit.HotelImplictCaseClass.Hotel)
[debug] Change NamesChange(com.local.ClassesAndObject.Implicit.HotelImplictCaseClass.Hotel,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(com;local;ClassesAndObject;Implicit;HotelImplictCaseClass;Hotel;init;,[Default]), UsedName(copy$default$2,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(apply,[Default]), UsedName(notify,[Default]), UsedName(unapply,[Default]), UsedName(curried,[Default]), UsedName(productElement,[Default]), UsedName(copy$default$1,[Default]), UsedName(name,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$3,[Default]), UsedName(copy,[Default]), UsedName(wait,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(productElementNames,[Default]), UsedName(toString,[Default]), UsedName(tupled,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(clone,[Default]), UsedName(productElementName,[Default]), UsedName(Hotel,[Default]), UsedName(address,[Default]), UsedName(UniqueID,[Default]), UsedName(notifyAll,[Default]), UsedName(productIterator,[Default]))) invalidates 1 classes due to The com.local.ClassesAndObject.Implicit.HotelImplictCaseClass.Hotel has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(com;local;ClassesAndObject;Implicit;HotelImplictCaseClass;Hotel;init;,[Default]), UsedName(copy$default$2,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(apply,[Default]), UsedName(notify,[Default]), UsedName(unapply,[Default]), UsedName(curried,[Default]), UsedName(productElement,[Default]), UsedName(copy$default$1,[Default]), UsedName(name,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$3,[Default]), UsedName(copy,[Default]), UsedName(wait,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(productElementNames,[Default]), UsedName(toString,[Default]), UsedName(tupled,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(clone,[Default]), UsedName(productElementName,[Default]), UsedName(Hotel,[Default]), UsedName(address,[Default]), UsedName(UniqueID,[Default]), UsedName(notifyAll,[Default]), UsedName(productIterator,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.ClassesAndObject.Implicit.HotelImplictCaseClass.Hotel)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.ReverseIteratorFunc...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.ReverseIteratorFunc)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.ReverseIteratorFunc)
[debug] Change NamesChange(com.local.CollectionFunction.ReverseIteratorFunc,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(hotelList,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(hotel,[Default]), UsedName(wait,[Default]), UsedName(ReverseIteratorFunc,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]), UsedName(reverseIteratorHotel,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.ReverseIteratorFunc has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(hotelList,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(hotel,[Default]), UsedName(wait,[Default]), UsedName(ReverseIteratorFunc,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]), UsedName(reverseIteratorHotel,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.ReverseIteratorFunc)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.TraitTraining.ExtMultiTraits.Equity...
[debug] Initial set of included nodes: Set(com.local.TraitTraining.ExtMultiTraits.Equity)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.TraitTraining.ExtMultiTraits.Equity)
[debug] The following modified names cause invalidation of com.local.TraitTraining.ExtMultiTraits.Trade: Set(UsedName(com;local;TraitTraining;ExtMultiTraits;Equity;init;,[Default]), UsedName(Equity,[Default]), UsedName(isActive,[Default]), UsedName(identifier,[Default]), UsedName(price,[Default]), UsedName(stats,[Default]))
[debug] The following modified names cause invalidation of com.local.TraitTraining.ExtMultiTraits.Client: Set(UsedName(com;local;TraitTraining;ExtMultiTraits;Equity;init;,[Default]), UsedName(Equity,[Default]), UsedName(stats,[Default]))
[debug] Change NamesChange(com.local.TraitTraining.ExtMultiTraits.Equity,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(com;local;TraitTraining;ExtMultiTraits;Equity;init;,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(Equity,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isActive,[Default]), UsedName(notify,[Default]), UsedName(identifier,[Default]), UsedName(productElement,[Default]), UsedName(price,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(productElementNames,[Default]), UsedName(stats,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(clone,[Default]), UsedName(productElementName,[Default]), UsedName(notifyAll,[Default]), UsedName(productIterator,[Default]))) invalidates 3 classes due to The com.local.TraitTraining.ExtMultiTraits.Equity has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(com;local;TraitTraining;ExtMultiTraits;Equity;init;,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(Equity,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isActive,[Default]), UsedName(notify,[Default]), UsedName(identifier,[Default]), UsedName(productElement,[Default]), UsedName(price,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(productElementNames,[Default]), UsedName(stats,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(clone,[Default]), UsedName(productElementName,[Default]), UsedName(notifyAll,[Default]), UsedName(productIterator,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.TraitTraining.ExtMultiTraits.Equity)
[debug] 	> 
[debug] 	> by member reference: Set(com.local.TraitTraining.ExtMultiTraits.Trade, com.local.TraitTraining.ExtMultiTraits.Client)
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.MinFunc...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.MinFunc)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.MinFunc)
[debug] Change NamesChange(com.local.CollectionFunction.MinFunc,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(MinFunc,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(hotel,[Default]), UsedName(wait,[Default]), UsedName(minPrice,[Default]), UsedName(ne,[Default]), UsedName(hotelPrice,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]), UsedName(minHotel,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.MinFunc has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(MinFunc,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(hotel,[Default]), UsedName(wait,[Default]), UsedName(minPrice,[Default]), UsedName(ne,[Default]), UsedName(hotelPrice,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]), UsedName(minHotel,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.MinFunc)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.TraitTraining.HotelFactory.Hotels.Hotel...
[debug] Initial set of included nodes: Set(com.local.TraitTraining.HotelFactory.Hotels.Hotel)
[debug] Including com.local.TraitTraining.HotelFactory.Hotels.OtherHotels by com.local.TraitTraining.HotelFactory.Hotels.Hotel
[debug] Including com.local.TraitTraining.HotelFactory.Hotels.PaperFactoryHotel by com.local.TraitTraining.HotelFactory.Hotels.Hotel
[debug] Including com.local.TraitTraining.HotelFactory.Hotels.FeatherFactoryHotel by com.local.TraitTraining.HotelFactory.Hotels.Hotel
[debug] Invalidated by transitive inheritance dependency: Set(com.local.TraitTraining.HotelFactory.Hotels.OtherHotels, com.local.TraitTraining.HotelFactory.Hotels.FeatherFactoryHotel, com.local.TraitTraining.HotelFactory.Hotels.Hotel, com.local.TraitTraining.HotelFactory.Hotels.PaperFactoryHotel)
[debug] The following modified names cause invalidation of com.local.TraitTraining.HotelFactory.HotelFactory: Set(UsedName(Hotel,[Default]))
[debug] The following modified names cause invalidation of com.local.TraitTraining.HotelFactory.HotelFactory: Set(UsedName(Hotel,[Default]))
[debug] The following modified names cause invalidation of com.local.TraitTraining.HotelFactory.HotelFactory: Set(UsedName(Hotel,[Default]))
[debug] The following modified names cause invalidation of com.local.TraitTraining.HotelFactory.Client: Set(UsedName(name,[Default]), UsedName(Hotel,[Default]))
[debug] The following modified names cause invalidation of com.local.TraitTraining.HotelFactory.HotelFactory: Set(UsedName(Hotel,[Default]))
[debug] Change NamesChange(com.local.TraitTraining.HotelFactory.Hotels.Hotel,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(name,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(clone,[Default]), UsedName(Hotel,[Default]), UsedName(notifyAll,[Default]))) invalidates 6 classes due to The com.local.TraitTraining.HotelFactory.Hotels.Hotel has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(name,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(clone,[Default]), UsedName(Hotel,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.TraitTraining.HotelFactory.Hotels.OtherHotels, com.local.TraitTraining.HotelFactory.Hotels.FeatherFactoryHotel, com.local.TraitTraining.HotelFactory.Hotels.Hotel, com.local.TraitTraining.HotelFactory.Hotels.PaperFactoryHotel)
[debug] 	> 
[debug] 	> by member reference: Set(com.local.TraitTraining.HotelFactory.HotelFactory, com.local.TraitTraining.HotelFactory.Client)
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.ClassesAndObject.Implicit.HotelImplictCaseClass.HotelImplicts.AugmentedHotel...
[debug] Initial set of included nodes: Set(com.local.ClassesAndObject.Implicit.HotelImplictCaseClass.HotelImplicts.AugmentedHotel)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.ClassesAndObject.Implicit.HotelImplictCaseClass.HotelImplicts.AugmentedHotel)
[debug] Change NamesChange(com.local.ClassesAndObject.Implicit.HotelImplictCaseClass.HotelImplicts.AugmentedHotel,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(com;local;ClassesAndObject;Implicit;HotelImplictCaseClass;HotelImplicts;AugmentedHotel;init;,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(doSomthingNewAfterCreatingACaseClass,[Default]), UsedName(ne,[Default]), UsedName(AugmentedHotel,[Implicit]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(clone,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.ClassesAndObject.Implicit.HotelImplictCaseClass.HotelImplicts.AugmentedHotel has the following implicit definitions changed:
[debug] 	UsedName(AugmentedHotel,[Implicit]).
[debug] 	> by transitive inheritance: Set(com.local.ClassesAndObject.Implicit.HotelImplictCaseClass.HotelImplicts.AugmentedHotel)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.DropWhileFunc...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.DropWhileFunc)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.DropWhileFunc)
[debug] Change NamesChange(com.local.CollectionFunction.DropWhileFunc,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(DropWhileFunc,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(dropZHotel,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(hotels,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.DropWhileFunc has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(DropWhileFunc,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(dropZHotel,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(hotels,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.DropWhileFunc)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Fixed_Income...
[debug] Initial set of included nodes: Set(com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Fixed_Income)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Fixed_Income)
[debug] The following modified names cause invalidation of com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Client_Covariance_Type: Set(UsedName(com;local;ClassesAndObject;Covariance_TypeWithContraVariance;Fixed_Income;init;,[Default]), UsedName(Fixed_Income,[Default]))
[debug] Change NamesChange(com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Fixed_Income,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(cost,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(copy$default$4,[Default]), UsedName(equals,[Default]), UsedName(quantity,[Default]), UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(couponPayments,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(yieldToMaturity,[Default]), UsedName(period,[Default]), UsedName(notify,[Default]), UsedName(faceAppreciation,[Default]), UsedName(interest,[Default]), UsedName(productElement,[Default]), UsedName(com;local;ClassesAndObject;Covariance_TypeWithContraVariance;Fixed_Income;init;,[Default]), UsedName(price,[Default]), UsedName(copy$default$1,[Default]), UsedName(copy$default$7,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(ytm,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$3,[Default]), UsedName(copy,[Default]), UsedName(copy$default$6,[Default]), UsedName(wait,[Default]), UsedName(stat,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(productElementNames,[Default]), UsedName(copy$default$5,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(terms,[Default]), UsedName(Fixed_Income,[Default]), UsedName(productArity,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(clone,[Default]), UsedName(productElementName,[Default]), UsedName(totalPeriods,[Default]), UsedName(couponTotalPayment,[Default]), UsedName(notifyAll,[Default]), UsedName(interstRatePerPeriod,[Default]), UsedName(typeOfInstrument,[Default]), UsedName(productIterator,[Default]))) invalidates 2 classes due to The com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Fixed_Income has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(cost,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(copy$default$4,[Default]), UsedName(equals,[Default]), UsedName(quantity,[Default]), UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(couponPayments,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(yieldToMaturity,[Default]), UsedName(period,[Default]), UsedName(notify,[Default]), UsedName(faceAppreciation,[Default]), UsedName(interest,[Default]), UsedName(productElement,[Default]), UsedName(com;local;ClassesAndObject;Covariance_TypeWithContraVariance;Fixed_Income;init;,[Default]), UsedName(price,[Default]), UsedName(copy$default$1,[Default]), UsedName(copy$default$7,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(ytm,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$3,[Default]), UsedName(copy,[Default]), UsedName(copy$default$6,[Default]), UsedName(wait,[Default]), UsedName(stat,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(productElementNames,[Default]), UsedName(copy$default$5,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(terms,[Default]), UsedName(Fixed_Income,[Default]), UsedName(productArity,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(clone,[Default]), UsedName(productElementName,[Default]), UsedName(totalPeriods,[Default]), UsedName(couponTotalPayment,[Default]), UsedName(notifyAll,[Default]), UsedName(interstRatePerPeriod,[Default]), UsedName(typeOfInstrument,[Default]), UsedName(productIterator,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Fixed_Income)
[debug] 	> 
[debug] 	> by member reference: Set(com.local.ClassesAndObject.Covariance_TypeWithContraVariance.Client_Covariance_Type)
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.TraitTraining.TypeParameters.FixedIncome...
[debug] Initial set of included nodes: Set(com.local.TraitTraining.TypeParameters.FixedIncome)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.TraitTraining.TypeParameters.FixedIncome)
[debug] The following modified names cause invalidation of com.local.TraitTraining.TypeParameters.Client: Set(UsedName(FixedIncome,[Default]), UsedName(com;local;TraitTraining;TypeParameters;FixedIncome;init;,[Default]))
[debug] Change NamesChange(com.local.TraitTraining.TypeParameters.FixedIncome,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(getLengthOfContract,[Default]), UsedName(ne,[Default]), UsedName(FixedIncome,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(time,[Default]), UsedName(com;local;TraitTraining;TypeParameters;FixedIncome;init;,[Default]), UsedName(getTypeOfContract,[Default]), UsedName(clone,[Default]), UsedName(desc,[Default]), UsedName(notifyAll,[Default]))) invalidates 2 classes due to The com.local.TraitTraining.TypeParameters.FixedIncome has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(getLengthOfContract,[Default]), UsedName(ne,[Default]), UsedName(FixedIncome,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(time,[Default]), UsedName(com;local;TraitTraining;TypeParameters;FixedIncome;init;,[Default]), UsedName(getTypeOfContract,[Default]), UsedName(clone,[Default]), UsedName(desc,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.TraitTraining.TypeParameters.FixedIncome)
[debug] 	> 
[debug] 	> by member reference: Set(com.local.TraitTraining.TypeParameters.Client)
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.TraitTraining.ExtMultiTraits.Security...
[debug] Initial set of included nodes: Set(com.local.TraitTraining.ExtMultiTraits.Security)
[debug] Including com.local.TraitTraining.ExtMultiTraits.Bond by com.local.TraitTraining.ExtMultiTraits.Security
[debug] Including com.local.TraitTraining.ExtMultiTraits.Equity by com.local.TraitTraining.ExtMultiTraits.Security
[debug] Invalidated by transitive inheritance dependency: Set(com.local.TraitTraining.ExtMultiTraits.Security, com.local.TraitTraining.ExtMultiTraits.Bond, com.local.TraitTraining.ExtMultiTraits.Equity)
[debug] The following modified names cause invalidation of com.local.TraitTraining.ExtMultiTraits.Trade: Set(UsedName(isActive,[Default]), UsedName(identifier,[Default]), UsedName(price,[Default]), UsedName(Security,[Default]), UsedName(stats,[Default]))
[debug] The following modified names cause invalidation of com.local.TraitTraining.ExtMultiTraits.Bond: Set(UsedName(asInstanceOf,[Default]), UsedName(isActive,[Default]), UsedName(identifier,[Default]), UsedName(price,[Default]), UsedName(Security,[Default]), UsedName(com;local;TraitTraining;ExtMultiTraits;Security;init;,[Default]))
[debug] The following modified names cause invalidation of com.local.TraitTraining.ExtMultiTraits.Client: Set(UsedName(Security,[Default]), UsedName(stats,[Default]))
[debug] The following modified names cause invalidation of com.local.TraitTraining.ExtMultiTraits.Equity: Set(UsedName(asInstanceOf,[Default]), UsedName(isActive,[Default]), UsedName(identifier,[Default]), UsedName(price,[Default]), UsedName(Security,[Default]), UsedName(com;local;TraitTraining;ExtMultiTraits;Security;init;,[Default]))
[debug] The following modified names cause invalidation of com.local.TraitTraining.ExtMultiTraits.Client: Set(UsedName(Security,[Default]), UsedName(stats,[Default]))
[debug] The following modified names cause invalidation of com.local.TraitTraining.ExtMultiTraits.Trade: Set(UsedName(isActive,[Default]), UsedName(identifier,[Default]), UsedName(price,[Default]), UsedName(Security,[Default]), UsedName(stats,[Default]))
[debug] The following modified names cause invalidation of com.local.TraitTraining.ExtMultiTraits.Client: Set(UsedName(Security,[Default]), UsedName(stats,[Default]))
[debug] Change NamesChange(com.local.TraitTraining.ExtMultiTraits.Security,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isActive,[Default]), UsedName(notify,[Default]), UsedName(identifier,[Default]), UsedName(productElement,[Default]), UsedName(price,[Default]), UsedName(Security,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(productElementNames,[Default]), UsedName(com;local;TraitTraining;ExtMultiTraits;Security;init;,[Default]), UsedName(stats,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(clone,[Default]), UsedName(productElementName,[Default]), UsedName(notifyAll,[Default]), UsedName(productIterator,[Default]))) invalidates 5 classes due to The com.local.TraitTraining.ExtMultiTraits.Security has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isActive,[Default]), UsedName(notify,[Default]), UsedName(identifier,[Default]), UsedName(productElement,[Default]), UsedName(price,[Default]), UsedName(Security,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(canEqual,[Default]), UsedName(ne,[Default]), UsedName(productElementNames,[Default]), UsedName(com;local;TraitTraining;ExtMultiTraits;Security;init;,[Default]), UsedName(stats,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName($init$,[Default]), UsedName(productPrefix,[Default]), UsedName(clone,[Default]), UsedName(productElementName,[Default]), UsedName(notifyAll,[Default]), UsedName(productIterator,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.TraitTraining.ExtMultiTraits.Security, com.local.TraitTraining.ExtMultiTraits.Bond, com.local.TraitTraining.ExtMultiTraits.Equity)
[debug] 	> 
[debug] 	> by member reference: Set(com.local.TraitTraining.ExtMultiTraits.Trade, com.local.TraitTraining.ExtMultiTraits.Bond, com.local.TraitTraining.ExtMultiTraits.Client, com.local.TraitTraining.ExtMultiTraits.Equity)
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.ClassesAndObject.Abstract.abstractHotel...
[debug] Initial set of included nodes: Set(com.local.ClassesAndObject.Abstract.abstractHotel)
[debug] Including com.local.ClassesAndObject.Abstract.HotelExtendsAbstract by com.local.ClassesAndObject.Abstract.abstractHotel
[debug] Including com.local.ClassesAndObject.Abstract.CaseHotelExtendedWithAbstact by com.local.ClassesAndObject.Abstract.abstractHotel
[debug] Invalidated by transitive inheritance dependency: Set(com.local.ClassesAndObject.Abstract.abstractHotel, com.local.ClassesAndObject.Abstract.CaseHotelExtendedWithAbstact, com.local.ClassesAndObject.Abstract.HotelExtendsAbstract)
[debug] The following modified names cause invalidation of com.local.ClassesAndObject.Abstract.HotelExtendsAbstract: Set(UsedName(abstractHotel,[Default]), UsedName(com;local;ClassesAndObject;Abstract;abstractHotel;init;,[Default]))
[debug] The following modified names cause invalidation of com.local.ClassesAndObject.Abstract.CaseHotelExtendedWithAbstact: Set(UsedName(asInstanceOf,[Default]), UsedName(eq,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(abstractHotel,[Default]), UsedName(com;local;ClassesAndObject;Abstract;abstractHotel;init;,[Default]))
[debug] The following modified names cause invalidation of com.local.ClassesAndObject.Abstract.ClientExtendOfHotelAbstract: Set(UsedName(stats,[Default]))
[debug] The following modified names cause invalidation of com.local.ClassesAndObject.Abstract.ClientExtendOfHotelAbstract: Set(UsedName(stats,[Default]))
[debug] Change NamesChange(com.local.ClassesAndObject.Abstract.abstractHotel,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(abstractHotel,[Default]), UsedName(ne,[Default]), UsedName(stats,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(clone,[Default]), UsedName(notifyAll,[Default]), UsedName(com;local;ClassesAndObject;Abstract;abstractHotel;init;,[Default]))) invalidates 4 classes due to The com.local.ClassesAndObject.Abstract.abstractHotel has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(abstractHotel,[Default]), UsedName(ne,[Default]), UsedName(stats,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(clone,[Default]), UsedName(notifyAll,[Default]), UsedName(com;local;ClassesAndObject;Abstract;abstractHotel;init;,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.ClassesAndObject.Abstract.abstractHotel, com.local.ClassesAndObject.Abstract.CaseHotelExtendedWithAbstact, com.local.ClassesAndObject.Abstract.HotelExtendsAbstract)
[debug] 	> 
[debug] 	> by member reference: Set(com.local.ClassesAndObject.Abstract.HotelExtendsAbstract, com.local.ClassesAndObject.Abstract.CaseHotelExtendedWithAbstact, com.local.ClassesAndObject.Abstract.ClientExtendOfHotelAbstract)
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.ClassesAndObject.Typed_Class.Motel...
[debug] Initial set of included nodes: Set(com.local.ClassesAndObject.Typed_Class.Motel)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.ClassesAndObject.Typed_Class.Motel)
[debug] The following modified names cause invalidation of com.local.ClassesAndObject.Typed_Class.TypedClient: Set(UsedName(Motel,[Default]), UsedName(com;local;ClassesAndObject;Typed_Class;Motel;init;,[Default]))
[debug] Change NamesChange(com.local.ClassesAndObject.Typed_Class.Motel,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(Motel,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(stats,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(com;local;ClassesAndObject;Typed_Class;Motel;init;,[Default]), UsedName(clone,[Default]), UsedName(notifyAll,[Default]))) invalidates 2 classes due to The com.local.ClassesAndObject.Typed_Class.Motel has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(equals,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(Motel,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(stats,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(com;local;ClassesAndObject;Typed_Class;Motel;init;,[Default]), UsedName(clone,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.ClassesAndObject.Typed_Class.Motel)
[debug] 	> 
[debug] 	> by member reference: Set(com.local.ClassesAndObject.Typed_Class.TypedClient)
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.TransposeFunc...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.TransposeFunc)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.TransposeFunc)
[debug] Change NamesChange(com.local.CollectionFunction.TransposeFunc,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(TransposeFunc,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(hotelsWithNameAndPrice,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(hotels,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]), UsedName(hotelsPrice,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.TransposeFunc has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(TransposeFunc,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(hotelsWithNameAndPrice,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(hotels,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]), UsedName(hotelsPrice,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.TransposeFunc)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.ReverseFunc...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.ReverseFunc)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.ReverseFunc)
[debug] Change NamesChange(com.local.CollectionFunction.ReverseFunc,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(ReverseFunc,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(reverseTickers,[Default]), UsedName(ne,[Default]), UsedName(tickers,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.ReverseFunc has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(ReverseFunc,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(reverseTickers,[Default]), UsedName(ne,[Default]), UsedName(tickers,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.ReverseFunc)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.review.Basic.ForControl...
[debug] Initial set of included nodes: Set(com.review.Basic.ForControl)
[debug] Invalidated by transitive inheritance dependency: Set(com.review.Basic.ForControl)
[debug] Change NamesChange(com.review.Basic.ForControl,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(bac,[Default]), UsedName(Stock,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(wfc,[Default]), UsedName(c,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(ForControl,[Default]), UsedName(stockName,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(portfolio,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(bx,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(listOfStock,[Default]), UsedName(jpm,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.review.Basic.ForControl has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(bac,[Default]), UsedName(Stock,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(wfc,[Default]), UsedName(c,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(ForControl,[Default]), UsedName(stockName,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(portfolio,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(bx,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(listOfStock,[Default]), UsedName(jpm,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.review.Basic.ForControl)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.review.Basic.IfElseControl...
[debug] Initial set of included nodes: Set(com.review.Basic.IfElseControl)
[debug] Invalidated by transitive inheritance dependency: Set(com.review.Basic.IfElseControl)
[debug] Change NamesChange(com.review.Basic.IfElseControl,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(Stock,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(IfElseControl,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(storeResult,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(bx,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.review.Basic.IfElseControl has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(Stock,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(IfElseControl,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(storeResult,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(bx,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.review.Basic.IfElseControl)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.Client...
[debug] Initial set of included nodes: Set(com.local.Client)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.Client)
[debug] Change NamesChange(com.local.Client,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(Client,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(time,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(paperHotel,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.Client has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(Client,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(time,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(paperHotel,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.Client)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.ReduceFunc...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.ReduceFunc)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.ReduceFunc)
[debug] Change NamesChange(com.local.CollectionFunction.ReduceFunc,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(concatenateHotel,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(hotelNames,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(maxHotelPrice,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(hotelPrices,[Default]), UsedName(sumHotelPrice,[Default]), UsedName(main,[Default]), UsedName(ReduceFunc,[Default]), UsedName(notifyAll,[Default]), UsedName(minHotelPrice,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.ReduceFunc has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(concatenateHotel,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(hotelNames,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(maxHotelPrice,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(hotelPrices,[Default]), UsedName(sumHotelPrice,[Default]), UsedName(main,[Default]), UsedName(ReduceFunc,[Default]), UsedName(notifyAll,[Default]), UsedName(minHotelPrice,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.ReduceFunc)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.TraitTraining.HotelFactory.Client...
[debug] Initial set of included nodes: Set(com.local.TraitTraining.HotelFactory.Client)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.TraitTraining.HotelFactory.Client)
[debug] Change NamesChange(com.local.TraitTraining.HotelFactory.Client,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(paperFactory,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(Client,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.TraitTraining.HotelFactory.Client has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(paperFactory,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(Client,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.TraitTraining.HotelFactory.Client)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.CollectionFunction.MkStringFunc...
[debug] Initial set of included nodes: Set(com.local.CollectionFunction.MkStringFunc)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.CollectionFunction.MkStringFunc)
[debug] Change NamesChange(com.local.CollectionFunction.MkStringFunc,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(MkStringFunc,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(hotels,[Default]), UsedName(ne,[Default]), UsedName(strHotels,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.CollectionFunction.MkStringFunc has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(MkStringFunc,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(hotels,[Default]), UsedName(ne,[Default]), UsedName(strHotels,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.CollectionFunction.MkStringFunc)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] Invalidating (transitively) by inheritance from com.local.ClassesAndObject.Typed_Class.TypedClient...
[debug] Initial set of included nodes: Set(com.local.ClassesAndObject.Typed_Class.TypedClient)
[debug] Invalidated by transitive inheritance dependency: Set(com.local.ClassesAndObject.Typed_Class.TypedClient)
[debug] Change NamesChange(com.local.ClassesAndObject.Typed_Class.TypedClient,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(listHotel,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(seqList,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(TypedClient,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(momAndDadANB,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(thirtySixMotel,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]))) invalidates 1 classes due to The com.local.ClassesAndObject.Typed_Class.TypedClient has the following regular definitions changed:
[debug] 	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(eq,[Default]), UsedName(getClass,[Default]), UsedName(listHotel,[Default]), UsedName(delayedInit,[Default]), UsedName(equals,[Default]), UsedName(args,[Default]), UsedName($asInstanceOf,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName($isInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(executionStart,[Default]), UsedName(seqList,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(TypedClient,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(momAndDadANB,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(thirtySixMotel,[Default]), UsedName(main,[Default]), UsedName(notifyAll,[Default]).
[debug] 	> by transitive inheritance: Set(com.local.ClassesAndObject.Typed_Class.TypedClient)
[debug] 	> 
[debug] 	> 
[debug]         
[debug] New invalidations:
[debug] 	Set()
[debug] Initial set of included nodes: Set()
[debug] Previously invalidated, but (transitively) depend on new invalidations:
[debug] 	Set()
[debug] All newly invalidated classes after taking into account (previously) recompiled classes:Set()
